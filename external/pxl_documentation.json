{
  "compileFnDocs": [
    {
      "body": {
        "name": "px.days",
        "brief": "Gets the specified number of days.",
        "examples": [
          {
            "value": "```\n# Returns 2 days.\ntime = px.days(2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "unit",
            "desc": "The number of days to render.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "Duration representing `unit` days.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.equals_any",
        "brief": "Returns true if the value is in the list.",
        "desc": "Check equality of the input value with every element of a list.   ",
        "examples": [
          {
            "value": "```\ndf.val = px.equals_any(df.remote_addr, ['10.0.0.1', '10.0.0.2'])\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "value",
            "desc": "The value to compare.",
            "types": [
              "px.Expr"
            ]
          },
          {
            "ident": "comparisons",
            "desc": "The list of values to check equality to the value.",
            "types": [
              "List[px.Expr]"
            ]
          }
        ],
        "returnType": {
          "desc": "An expression that evaluates to true if the value is found in the list.",
          "types": [
            "px.Expr"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.hours",
        "brief": "Gets the specified number of hours.",
        "examples": [
          {
            "value": "```\n# Returns 2 hours.\ntime = px.hours(2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "unit",
            "desc": "The number of hours to render.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "Duration representing `unit` hours.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.make_upid",
        "brief": "Create a UPID from its components to represent a process.",
        "desc": "Creates a UPID object from asid, pid, and time started in nanoseconds. UPID stands for unique PID and is a Pixie concept to ensure tracked processes are unique in time and across nodes.  Note: Creating this value from scratch might be very difficult, especially given the nanosecond timestamp. It's probably only useful if you find the UPID printed out as it's constituent components.  In most situations, you might find that `px.uint128` is a better option as we often render UPID as uuid.   ",
        "examples": [
          {
            "value": "```\nval = px.make_upid(123, 456, 1598419816000000)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "asid",
            "desc": "The ID of the node, according to the Pixie metadata service. Stands for Agent short ID.",
            "types": [
              "int"
            ]
          },
          {
            "ident": "pid",
            "desc": "The PID of the process on the node.",
            "types": [
              "int"
            ]
          },
          {
            "ident": "ts_ns",
            "desc": "The start time of the process in unix time.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "The represented UPID.",
          "types": [
            "px.UPID"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.microseconds",
        "brief": "Gets the specified number of microseconds.",
        "examples": [
          {
            "value": "```\n# Returns 2 microseconds.\ntime = px.microseconds(2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "unit",
            "desc": "The number of microseconds to render.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "Duration representing `unit` microseconds.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.milliseconds",
        "brief": "Gets the specified number of milliseconds.",
        "examples": [
          {
            "value": "```\n# Returns 2 milliseconds.\ntime = px.milliseconds(2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "unit",
            "desc": "The number of milliseconds to render.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "Duration representing `unit` milliseconds.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.minutes",
        "brief": "Gets the specified number of minutes.",
        "examples": [
          {
            "value": "```\n# Returns 2 minutes.\ntime = px.minutes(2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "unit",
            "desc": "The number of minutes to render.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "Duration representing `unit` minutes.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.now",
        "brief": "Get the current time.",
        "examples": []
      },
      "funcDoc": {
        "args": [],
        "returnType": {
          "desc": "The current time as defined at the start of compilation.",
          "types": [
            "px.Time"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.parse_duration",
        "brief": "Parse a duration string to a duration in nanoseconds.",
        "desc": "Parse a duration string (\"-5m\") to integer nanoseconds (-3,000,000,000) while preserving the sign from the string.   ",
        "examples": [
          {
            "value": "```\n# duration = -300000000000\nduration = px.parse_duration(\"-5m\")\n# duration = 300000000000\nduration = px.parse_duration(\"5m\")\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "duration",
            "desc": "The duration in string form.",
            "types": [
              "string"
            ]
          }
        ],
        "returnType": {
          "desc": "The duration in nanoseconds.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.parse_time",
        "brief": "Parse the various time formats into a unified format.",
        "desc": "This function can unify all possible time formats into a single consistent type. Useful for doing calculations on these values in a way that is agnostic to their format.   ",
        "examples": [
          {
            "value": "```\n## As a relative time string.\n# time = now -300000000000\ntime = px.parse_time(\"-5m\")\n# time = now + 300000000000\ntime = px.parse_time(\"5m\")\n# Takes in px.Time\ntime = px.parse_time(px.strptime(\"2020-03-12 19:39:59 -0200\", \"%Y-%m-%d %H:%M:%S %z\"))\n# Takes in int\ntime = px.parse_time(10)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "time",
            "desc": "The time as a string, int, or px.Time.",
            "types": [
              "string, int, time"
            ]
          }
        ],
        "returnType": {
          "desc": "The unix timestamp in nanoseconds.",
          "types": [
            "px.Time"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.script_reference",
        "brief": "Create a reference to a PxL script.",
        "desc": "Create a reference to a PxL script with specified script arguments. These values are displayed in the UI as a clickable link to execute that PxL script.   ",
        "examples": [
          {
            "value": "```\ndf.script = px.script_reference(df.namespace, 'px/namespace', {'namespace': df.namespace, 'start_time': '-5m'})\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "label",
            "desc": "A value containing the label text for the output deep link.",
            "types": [
              "string"
            ]
          },
          {
            "ident": "script",
            "desc": "The script ID to execute, such as 'px/namespace'.",
            "types": [
              "string"
            ]
          },
          {
            "ident": "args",
            "desc": "A dictionary containing the script argument values.",
            "types": [
              "dictionary"
            ]
          }
        ],
        "returnType": {
          "desc": "A stringified JSON representing the script, shown in the UI as a link.",
          "types": [
            "string"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.seconds",
        "brief": "Gets the specified number of seconds.",
        "examples": [
          {
            "value": "```\n# Returns 2 seconds.\ntime = px.seconds(2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "unit",
            "desc": "The number of seconds to render.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "Duration representing `unit` seconds.",
          "types": [
            "px.Duration"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.strptime",
        "brief": "Parse a datestring into a px.Time.",
        "desc": "Parse a datestring using a standard time format template into an internal time representation. The format must follow the C strptime format, outlined in this document: https://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html   ",
        "examples": [
          {
            "value": "```\ntime = px.strptime(\"2020-03-12 19:39:59 -0200\", \"%Y-%m-%d %H:%M:%S %z\")\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "date_string",
            "desc": "The time as a string, should match the format object.",
            "types": [
              "string"
            ]
          },
          {
            "ident": "format",
            "desc": "The string format according to the C strptime format https://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html",
            "types": [
              "string"
            ]
          }
        ],
        "returnType": {
          "desc": "The time value represented in the data.",
          "types": [
            "px.Time"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.uint128",
        "brief": "Parse the UUID string into a UInt128.",
        "desc": "Parse the UUID string of canonical textual representation into a 128bit integer (ie \"123e4567-e89b-12d3-a456-426614174000\"). Errors out if the string is not the correct format.   ",
        "examples": [
          {
            "value": "```\nval = px.uint128(\"123e4567-e89b-12d3-a456-426614174000\")\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "uuid",
            "desc": "the uuid in canoncial uuid4 format (\"123e4567-e89b-12d3-a456-426614174000\")",
            "types": [
              "string"
            ]
          }
        ],
        "returnType": {
          "desc": "The uuid as a uint128.",
          "types": [
            "uint128"
          ]
        }
      }
    }
  ],
  "dataframeOpDocs": [
    {
      "body": {
        "name": "DataFrame.DataFrame",
        "brief": "Sets up a DataFrame object from the specified table.",
        "desc": "Sets up the loading procedure of the table into the rest of the execution engine. The returned value can be transformed, aggregated and filtered using the DataFrame methods.  Note that we are not actually loading data until the entire query is compiled, meaning that running this by itself won't do anything until a full pipeline is constructed.  DataFrame is able to load in any set of tables. See `px.GetSchemas()` for a list of tables and the columns that can be loaded.     ",
        "examples": [
          {
            "value": "```\n# Select all columns\ndf = px.DataFrame('http_events', start_time='-5m')\n```"
          },
          {
            "value": "```\n# Select subset of columns.\ndf = px.DataFrame('http_events', select=['upid', 'req_body'], start_time='-5m')\n```"
          },
          {
            "value": "```\n# Absolute time specification.\ndf = px.DataFrame('http_events', start_time='2020-07-13 18:02:5.00 -0700')\n```"
          },
          {
            "value": "```\n# Absolute time sepecification (nanoseconds). Note this format only works for PxL scripts;\n# The Live UI's `start_time` argument does not support this format.\ndf = px.DataFrame('http_events', start_time=1646157769000000000)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "table",
            "desc": "The table name to load.",
            "types": [
              "string"
            ]
          },
          {
            "ident": "select",
            "desc": "The columns of the table to load. Leave empty if you want to select all.",
            "types": [
              "List[str]]"
            ]
          },
          {
            "ident": "start_time",
            "desc": "The earliest timestamp of data to load. The format can be one of the following: (1) relative time with format \"-5m\" or \"-3h\", (2) absolute time with format \"2020-07-13 18:02:5.00 +0000\", (3) absolute time in nanoseconds, or (4) `None`. Defaults to `None`. If `start_time` is `None`, then it begins with the first record in the table.",
            "types": [
              "px.Time"
            ]
          },
          {
            "ident": "end_time",
            "desc": "The last timestamp of data to load. The format can be one of the following: (1) relative time with format \"-5m\" or \"-3h\", (2) absolute time with format \"2020-07-13 18:02:5.00 +0000\", (3) absolute time in nanoseconds, or (4) `None`. Defaults to `None`. If `end_time` is `None` and `df.stream()` was not called on this DataFrame, then this DataFrame will process data until the last record that was in the table at the beginning of query execution. If `end_time` is `None` and `df.stream()` was called on this DataFrame, then this DataFrame will process data indefinitely.",
            "types": [
              "px.Time"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame loaded from the table with the specified columns and time period.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.__getitem__",
        "brief": "Keeps only the specified columns.",
        "desc": "Returns a DataFrame with only the specified columns. Useful for pruning columns to a small set before data is displayed. See `drop()` on how to drop specific columns instead.     ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('process_stats', select=['upid', 'cpu_ktime_ns', 'rss_bytes'])\n# Keep only the upid and rss_bytes columns\ndf = df[['upid', 'rss_bytes']]\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "columns",
            "desc": "DataFrame columns to keep.",
            "types": [
              "List[str]"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame with the specified columns removed.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.agg",
        "brief": "Aggregates the data based on the expressions.",
        "desc": "Computes the aggregate expressions on the data. If the preceding operator is a groupby, then we evaluate the aggregate expression in each group. If not, we calculate the aggregate expression using all of the preceding data. If no arguments specified and the call follows a grouped DataFrame, then agg() returns the unique groups. If following a non-grouped DataFrame agg() with no args will yield a compilation error.  Each aggregate expression is simply the aggregate function applied to a column, formatted as `\u003cout_col_name\u003e=(\"\u003ccolumn_name\u003e\", \u003cfunction\u003e)`. A list of functions are available in the [UDA docs](/reference/pxl/udf)     ",
        "examples": [
          {
            "value": "```\n# Group by UPID and calculate maximum user time for the each\n# UPID group.\ndf = px.DataFrame('process_stats')\ndf = df.groupby('upid').agg(cpu_utime=('cpu_utime_ns', px.max))\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "**kwargs",
            "desc": "The column, aggregate function pair that make up the expression to apply, assigned to the output column name. `\u003cout_col_name\u003e=(\"\u003ccolumn_name\u003e\", \u003cfunction\u003e)`. If this value is empty, it will return the unique groups in the previous DataFrame.",
            "types": [
              "Tuple[string, AggFn]"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame with aggregated expressions evaluated containing the groups (if any) followed by the output column aggregate expression names.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.append",
        "brief": "Unions the passed in dataframes with this DataFrame.",
        "desc": "Unions the rows of the passed in DataFrames with this DataFrame. The passed in DataFrames. must have the same relation or `append` will throw a compilation error. Use `merge` to combine DataFrames with different relations.  If there is a time column in the relation, `append` sorts the Unioned data by time. If there is no time column, then append will simply return a DataFrame with each DataFrame stacked on the other.     ",
        "examples": [
          {
            "value": "```\ndf1 = px.DataFrame('process_stats', start_time='-10m', end_time='-9m')\ndf2 = px.DataFrame('process_stats', start_time='-1m')\ndf = df1.append(df2)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "other",
            "desc": "The DataFrame to union with this one, relation must be the same.",
            "types": [
              "px.DataFrame"
            ]
          }
        ],
        "returnType": {
          "desc": "This DataFrame unioned with the passed in argument.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.ctx.__getitem__",
        "brief": "Creates the specified metadata as a column.",
        "desc": "Shorthand for exposing metadata columns in the DataFrame. Each metadata type can be converted from some sets of other metadata types that already exist in the DataFrame.  Attempting to convert to a metadata type that doesn't have the source column will raise a compiler error.  Available keys (and any aliases) as well as the source columns. \n* container_id (): Sources: \"upid\" \n* service_id: Sources: \"upid\",\"service_name\" \n* service_name (\"service\"): Sources: \"upid\",\"service_id\" \n* pod_id: Sources: \"upid\",\"pod_name\" \n* pod_name (\"pod\"): Sources: \"upid\",\"pod_id\" \n* deployment_id: Sources: \"deployment_name\",\"pod_id\",\"pod_name\",\"replicaset_name\", \"replicaset_id\" \n* deployment_name (\"deployment\"): Sources: \"upid\",\"deployment_id\",\"pod_id\",\"pod_name\",\"replicaset_name\", \"replicaset_id\" \n* replicaset_id (\"replica_set_id\"): Sources: \"upid\",\"pod_id\",\"pod_name\", \"replicaset_name\" \n* replicaset_name (\"replica_set\", \"replicaset\"): Sources: \"upid\",\"pod_id\",\"pod_name\", \"replicaset_id\" \n* namespace: Sources: \"upid\" \n* node_name (\"node\"): Sources: \"upid\" \n* hostname (\"host\"): Sources: \"upid\" \n* container_name (\"container\"): Sources: \"upid\" \n* cmdline (\"cmd\"): Sources: \"upid\" \n* asid: Sources: \"upid\" \n* pid: Sources: \"upid\"      ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('http_events', start_time='-5m')\n# Filter only for data that matches the metadata service.\n# df.ctx['service'] pulls the service column into the DataFrame.\ndf = df[df.ctx['service'] == \"pl/vizier-metadata\"]\n```"
          },
          {
            "value": "```\ndf = px.DataFrame('http_events', start_time='-5m')\n# Add the service column from the metadata object.\ndf.service = df.ctx['service']\n# Group by the service.\ndf = df.groupby('service').agg(req_count=('service', px.count))\n```"
          },
          {
            "value": "```\n# Where metadata context can fail.\ndf = px.DataFrame('http_events', start_time='-5m')\n# Dropping upid so we remove the \"source\" column we could use\ndf = df.drop('upid')\n# FAILS: no source column available for the metadata conversion.\ndf.service = df.ctx['service']\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "metadata",
            "desc": "The metadata property you wish to access. Function will throw an error if it doesn't exist.",
            "types": [
              "string"
            ]
          }
        ],
        "returnType": {
          "desc": "Column that represents the metadata in the DataFrame. Can be used in a DataFrame expression.",
          "types": [
            "px.Column"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.drop",
        "brief": "Drops the specified columns from the DataFrame.",
        "desc": "Returns a DataFrame with the specified columns dropped. Useful for removing columns you don't want to see in the final table result.  See `keep()` on how to specify which columns to keep.     ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('process_stats', select=['upid', 'cpu_ktime_ns', 'cpu_utime_ns'])\n# Drop upid from df.\ndf = df.drop('upid')\n```"
          },
          {
            "value": "```\ndf = px.DataFrame('process_stats', select=['upid', 'cpu_ktime_ns', 'cpu_utime_ns'])\n# Drop upid an cpu_ktime_ns from df.\ndf = df.drop(['upid', 'cpu_ktime_ns'])\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "columns",
            "desc": "DataFrame columns to drop, either as a string or a list.",
            "types": [
              "Union[str,List[str]]"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame with the specified columns removed.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.filter",
        "brief": "Returns a DataFrame with only those rows that match the condition.",
        "desc": "Filters for the rows in the DataFrame that match the boolean condition. Will error out if you don't pass in a boolean expression. The functions available are defined in [UDFs](/reference/pxl/udf).     ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('http_events')\n# Filter for only http requests that are greater than 100 milliseconds\ndf = df[df['resp_latency_ns'] \u003e 100 * 1000 * 1000]\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "key",
            "desc": "DataFrame expression that evaluates to a bool. Filter keeps any row that causes the expression to evaluate to True.",
            "types": [
              "ScalarExpression"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame with only those rows that return True for the expression.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.groupby",
        "brief": "Groups the data in preparation for an aggregate.",
        "desc": "Groups the data by the unique values in the passed in columns. At the current time we do not support standalone groupings, you must always follow the groupby() call with a call to `agg()`.     ",
        "examples": [
          {
            "value": "```\n# Group by UPID and calculate maximum user time for the each\n# UPID group.\ndf = px.DataFrame('process_stats')\ndf = df.groupby('upid').agg(cpu_utime=('cpu_utime_ns', px.max))\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "columns",
            "desc": "DataFrame columns to group by, either as a string or a list.",
            "types": [
              "Union[str,List[str]]"
            ]
          }
        ],
        "returnType": {
          "desc": "Grouped DataFrame. Must be followed by a call to `agg()`.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.head",
        "brief": "Return the first n rows.",
        "desc": "Returns a DataFrame with the first n rows of data.     ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('http_events')\n# Keep only the first 100 http requests.\ndf = df.head(100)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "n",
            "desc": "The number of rows to return. If not set, default is 5.",
            "types": [
              "int"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame with the first n rows.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.map",
        "brief": "Sets up the runtime expression and assigns the result to the specified column.",
        "desc": "Adds a column with the specified name and the expression that evaluates to the column value. The evaluation of this expression happens inside of the Pixie engine (Carnot) thus cannot be directly accessed during compilation.  The expression can be a scalar value, a column from the same dataframe, or a [UDF](/reference/pxl/udf) function call. The syntax can be either `df['colname'] = expr` or `df.colname = expr`, the second option is simply syntactic sugar. The first form is slightly more expressive as you can set column names with spaces.       ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('process_stats')\n# Map scalar value to a column.\ndf['number'] = 12\n```"
          },
          {
            "value": "```\ndf = px.DataFrame('http_events')\ndf.svc = df.ctx['svc']\n# Map column to another column name.\ndf.resp_body = df.resp_body\n```"
          },
          {
            "value": "```\ndf = px.DataFrame('http_events')\n# Map expression to the column.\ndf['latency_ms'] = df['resp_latency_ns'] / 1.0e9\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "column_name",
            "desc": "The name of the column to assign this value.",
            "types": [
              "str"
            ]
          },
          {
            "ident": "expr",
            "desc": "The expression to evaluate in Carnot.",
            "types": [
              "ScalarExpression"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame with the new column added.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.merge",
        "brief": "Merges the input DataFrame with this one using a database-style join.",
        "desc": "Joins this DataFrame with the passed in right DataFrame according to the specified Join type. The DataFrame that we apply this on is the left DataFrame. The one passed in as an argument is the right DataFrame. If the join keys do not have the same type, this will error out.     ",
        "examples": [
          {
            "value": "```\n# Single join key: Group by UPID and calculate maximum user time for the each UPID group.\nleft_df = px.DataFrame('process_stats', start_time='-10s')\nleft_df = left_df.groupby('upid').agg(cpu_utime=('cpu_utime_ns', px.max))\nright_df = px.DataFrame('http_events', start_time='-10s')\nright_df = right_df.groupby('upid').agg(count=('resp_body', px.count))\ndf = left_df.merge(right_df, how='inner', left_on='upid', right_on='upid', suffixes=['', '_x'])\n# Output relation: ['upid', 'cpu_utime', 'upid_x', 'count']\n# Multiple join keys: Calculate maximum user time for the each service/node pair.\nleft_df = px.DataFrame('process_stats', start_time='-10s')\nleft_df.node = left_df.ctx['node']\nleft_df.service = left_df.ctx['service']\nleft_df = left_df.groupby(['service', 'node']).agg(cpu_utime=('cpu_utime_ns', px.max))\nright_df = px.DataFrame('http_events', start_time='-10s')\nright_df.node = right_df.ctx['node']\nright_df.service = right_df.ctx['service']\nright_df = right_df.groupby(['service', 'node']).agg(count=('resp_body', px.count))\ndf = left_df.merge(right_df, how='inner', left_on=['service', 'node'], right_on=['service', 'node'], suffixes=['', '_x'])\n# Output relation: ['service', 'node', 'cpu_utime', 'service_x', 'node_x', 'count']\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "right",
            "desc": "The DataFrame to join with this DataFrame.",
            "types": [
              "px.DataFrame"
            ]
          },
          {
            "ident": "how",
            "desc": "the type of merge (join) to perform. * inner: use the intersection of the left and right keys. * outer: use the union of the left and right keys. * left: use the keys from the left DataFrame. * right: use the keys from the right DataFrame.",
            "types": [
              "['inner', 'outer', 'left', 'right'], default 'inner'"
            ]
          },
          {
            "ident": "left_on",
            "desc": "Column name from this DataFrame, either as a string or a list of strings.",
            "types": [
              "Union[string, List[string]]"
            ]
          },
          {
            "ident": "right_on",
            "desc": "Column name from the right DataFarme to join on. Must be the same type as the `left_on` column.",
            "types": [
              "Union[string, List[string]]"
            ]
          },
          {
            "ident": "suffixes",
            "desc": "The suffixes to apply to duplicate columns.",
            "types": [
              "Tuple[string, string], default ['_x', '_y']"
            ]
          }
        ],
        "returnType": {
          "desc": "Merged DataFrame with the relation [left_join_col, ...remaining_left_columns, ...remaining_right_columns].",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.rolling",
        "brief": "Groups the data by rolling windows.",
        "desc": "Rolls up data into groups based on the rolling window that it belongs to. Used to define window aggregates, the streaming analog of batch aggregates.      ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('process_stats')\ndf = df.rolling('2s').agg(...)\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "window",
            "desc": "the size of the rolling window.",
            "types": [
              "px.Duration"
            ]
          }
        ],
        "returnType": {
          "desc": "DataFrame grouped into rolling windows. Must apply either a groupby or an aggregate on the returned DataFrame.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "DataFrame.stream",
        "brief": "Execute this DataFrame in streaming mode.",
        "desc": "Returns the input DataFrame, but set to streaming mode. Streaming queries execute indefinitely, as opposed to batch queries which return a finite result.     ",
        "examples": [
          {
            "value": "```\ndf = px.DataFrame('http_events').stream()\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [],
        "returnType": {
          "desc": "the parent DataFrame in streaming mode.",
          "types": [
            "px.DataFrame"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.debug",
        "brief": "Outputs the data from the engine as a debug table",
        "desc": "Writes the data to the output stream, prefixing the name with `_`. Unlike `px.display` if executing the script with Vis functions, this will still write to the output table. Debug tables are displayed in the data drawer in the Live UI. To show / hide the data drawer use cmd+d (Mac) or ctrl+d (Windows, Linux).   ",
        "examples": [
          {
            "value": "```\npx.debug(df, 'test_data')\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "out",
            "desc": "The DataFrame to write out to the output stream.",
            "types": [
              "px.DataFrame"
            ]
          },
          {
            "ident": "name",
            "desc": "The output table name for the DataFrame. If not set, then will be 'output'. If the name is duplicated across all written tables, we suffix with `_1`, incrementing for every duplicate.",
            "types": [
              "string"
            ]
          }
        ]
      }
    },
    {
      "body": {
        "name": "px.display",
        "brief": "Outputs the data from the engine.",
        "desc": "Writes the data to the output stream. Disabled if executing using Vis functions. If you want to still see data when using vis fucntions, use `px.debug`.   ",
        "examples": [
          {
            "value": "```\npx.display(df, 'http_data')\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "out",
            "desc": "The DataFrame to write out to the output stream.",
            "types": [
              "px.DataFrame"
            ]
          },
          {
            "ident": "name",
            "desc": "The output table name for the DataFrame. If not set, then will be 'output'. If the name is duplicated across all written tables, we suffix with `_1`, incrementing for every duplicate.",
            "types": [
              "string"
            ]
          }
        ]
      }
    },
    {
      "body": {
        "name": "px.export",
        "brief": "Sends a DataFrame from Pixie to the specified output.",
        "desc": "Writes the data to the specified output destination. For example, can be used to specify an export to OpenTelemetry using the methods available in `px.otel.trace` or `px.otel.metrics`.   ",
        "examples": [
          {
            "value": "```\npx.export(df, px.otel.Data(...))\n```"
          }
        ]
      },
      "funcDoc": {
        "args": [
          {
            "ident": "out",
            "desc": "The DataFrame to write out to the output stream.",
            "types": [
              "px.DataFrame"
            ]
          },
          {
            "ident": "export_spec",
            "desc": "The destination specification for the DataFrame data.",
            "types": [
              "Exporter"
            ]
          }
        ]
      }
    }
  ],
  "mutationDocs": [
    {
      "body": {
        "name": "pxtrace.DeleteTracepoint",
        "brief": "Deletes a tracepoint.",
        "desc": "Deletes the tracepoint with the provided name, should it exist.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "name",
            "desc": "The name of the tracepoint.",
            "types": [
              "str"
            ]
          }
        ]
      }
    },
    {
      "body": {
        "name": "pxtrace.UpsertTracepoint",
        "brief": "Deploys a tracepoint on a process and collects the traced data into a table.",
        "desc": "Deploys the tracepoint on the process (UPID) for the specified amount of time (TTL). The provided name uniquely identifies the tracepoint, and is used to manage the tracepoint (e.g. future calls to `UpsertTracepoint` or `DeleteTracepoint`.) A call to `UpsertTracepoint` on an existing tracepoint resets the TTL, but otherwise has no effect. A call to `UpsertTracepoint` on an existing tracepoint with a different tracepoint function will fail. UpsertTracepoint automatically creates a table with the provided name should it not exist; if the table exists but has a different schema, the deployment will fail.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "name",
            "desc": "The name of the tracepoint. Should be unique with the probe_fn.",
            "types": [
              "str"
            ]
          },
          {
            "ident": "table_name",
            "desc": "The table name to write the results. The table is created if it does not exist. The table schema must match if the table does exist.",
            "types": [
              "str"
            ]
          },
          {
            "ident": "probe_fn",
            "desc": "The tracepoint function.",
            "types": [
              "px.ProbeFn"
            ]
          },
          {
            "ident": "target",
            "desc": "The process or shared object to trace as specified by unique Vizier PID.",
            "types": [
              "Union[px.UPID,px.SharedObject,pxtrace.PodProcess,pxtrace.LabelSelector]"
            ]
          },
          {
            "ident": "ttl",
            "desc": "The length of time that a tracepoint will stay alive, after which it will be removed.",
            "types": [
              "px.Duration"
            ]
          }
        ]
      }
    }
  ],
  "otelDocs": [
    {
      "body": {
        "name": "px.otel.Data",
        "brief": "Specifies the transformation of a DataFrame into OpenTelemetry data.",
        "desc": "This function makes it easy to transform columnar DataFrame data into single element OpenTelemetry data. User must pass in data configuration(s) (ie `px.otel.metric.Gauge`) and a resource config where `service.name` is one of the attributes.  Optionally, users can specify an endpoint using `px.otel.Endpoint`.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "data",
            "desc": "The list of OTel configurations for the data, describing how the data is created in the DataFrame and what kind of metric to populate in OTel.",
            "types": [
              "List[px.otel.Data]"
            ]
          },
          {
            "ident": "resource",
            "desc": "A description of the resource that creates this data. Is a mapping of attribute name to a string or a column that stores data about the attribute. Must include 'service.name' as one attribute.",
            "types": [
              "Dict[string, Column|string]"
            ]
          },
          {
            "ident": "endpoint",
            "desc": "The endpoint configuration value. The endpoint can be omitted if this script is run in the OTel plugin context where an endpoint is configured.",
            "types": [
              "px.otel.Endpoint, optional"
            ]
          }
        ],
        "returnType": {
          "desc": "the description of how to map a DataFrame to OpenTelemetry Data. Can be passed into `px.export`.",
          "types": [
            "Exporter"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.otel.Endpoint",
        "brief": "The Collector destination for exported OpenTelemetry data.",
        "desc": "Describes the endpoint and any connection arguments necessary to talk to an OpenTelemetry collector. Passed as an argument to `px.otel.Data`.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "url",
            "desc": "The URL of the OTel collector.",
            "types": [
              "string"
            ]
          },
          {
            "ident": "headers",
            "desc": "The connection metadata to add to the header of the request.",
            "types": [
              "Dict[string,string], optional"
            ]
          },
          {
            "ident": "insecure",
            "desc": "Whether to allow insecure connections to the OpenTelemetry collector. False by default.",
            "types": [
              "bool, optional"
            ]
          },
          {
            "ident": "timeout",
            "desc": "The number of seconds before the request should timeout when exporting to the OTel collector.",
            "types": [
              "int, optional"
            ]
          }
        ]
      }
    },
    {
      "body": {
        "name": "px.otel.metric.Gauge",
        "brief": "Defines the DataFrame mapping to an OpenTelemetry Metric Gauge",
        "desc": "[Gauges](https://opentelemetry.io/docs/reference/specification/metrics/datamodel/#gauge) specify the \"current value\" of a metric at a given time. The source DataFrame must have a `time_` column of type `TIME64NS` or the compiler will throw an error.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "name",
            "desc": "The name of the metric. Must adhere to [OpenTelemetry's naming conventions](https://opentelemetry.io/docs/reference/specification/metrics/api/#instrument)",
            "types": [
              "string"
            ]
          },
          {
            "ident": "value",
            "desc": "The column that contains the data. Must be either an INT64 or a FLOAT64.",
            "types": [
              "Column"
            ]
          },
          {
            "ident": "description",
            "desc": "A description of what the metric tracks.",
            "types": [
              "string, optional"
            ]
          },
          {
            "ident": "attributes",
            "desc": "A mapping of attribute name to a string or the column that stores data about the attribute.",
            "types": [
              "Dict[string, Column|string], optional"
            ]
          },
          {
            "ident": "unit",
            "desc": "The unit string to use for the metric. If not specified, will attempt to use the Semantic Type of the `value` to infer the unit string.",
            "types": [
              "string, optional"
            ]
          }
        ],
        "returnType": {
          "desc": "the mapping of DataFrame columns to OpenTelemetry Gauge fields. Can be passed into `px.otel.Data()` as the data argument.",
          "types": [
            "OTelDataContainer"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.otel.metric.Summary",
        "brief": "Defines the DataFrame mapping to an OpenTelemetry Metric Summary",
        "desc": "Summaries describe distributions by recording quantile values (aka percentile values) such as p50, p90 and p99. User specify as many of these point values as they like, labeling them with the float equivalent position in the distribution. Ie p50 would be labeled `0.5`, p99 as `0.99`. The source DataFrame must have a `time_` column of type `TIME64NS` or the compiler will throw an error. The unit of this metric will be inferred from the [SemanticType](https://github.com/pixie-io/pixie/blob/main/src/api/proto/vizierpb/vizierapi.proto#L51) of the column `value`.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "name",
            "desc": "The name of the metric.",
            "types": [
              "string"
            ]
          },
          {
            "ident": "count",
            "desc": "The column of the count of elements inside each summary. Must be INT64",
            "types": [
              "Column"
            ]
          },
          {
            "ident": "sum",
            "desc": "The column of the sum of elements in inside each summary to use for the Summary. Must be FLOAT64",
            "types": [
              "Column"
            ]
          },
          {
            "ident": "quantile_values",
            "desc": "The mapping of the quantile value to the DataFrame column containing the quantile value information. Must be FLOAT64.",
            "types": [
              "Dict[float, Column]"
            ]
          },
          {
            "ident": "description",
            "desc": "A description of what the metric tracks.",
            "types": [
              "string, optional"
            ]
          },
          {
            "ident": "attributes",
            "desc": "A mapping of attribute name to a string or the column that stores data about the attribute.",
            "types": [
              "Dict[string, Column|string], optional"
            ]
          },
          {
            "ident": "unit",
            "desc": "The unit string to use for the metric. If not specified, will attempt to use the Semantic Type of the quantile values to infer the unit string.",
            "types": [
              "string, optional"
            ]
          }
        ],
        "returnType": {
          "desc": "the mapping of DataFrame columns to OpenTelemetry Summary fields. Can be passed into `px.otel.Data()` as the data argument.",
          "types": [
            "OTelDataContainer"
          ]
        }
      }
    },
    {
      "body": {
        "name": "px.otel.trace.Span",
        "brief": "Defines the OpenTelemetry Trace Span type.",
        "desc": "Span describes how to transform a pixie DataFrame into the OpenTelemetry Span type.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "name",
            "desc": "The name of the span. Can be a string or a STRING column.",
            "types": [
              "string,Column"
            ]
          },
          {
            "ident": "start_time",
            "desc": "The column that marks the beginning of the span, must be TIME64NS.",
            "types": [
              "Column"
            ]
          },
          {
            "ident": "end_time",
            "desc": "The column that marks the end of the span, must be TIME64NS.",
            "types": [
              "Column"
            ]
          },
          {
            "ident": "trace_id",
            "desc": "The column containing trace_ids, must be formatted as a lower-case hex with 32 hex characters (aka 16 bytes), or the engine will auto-generate a new ID. If not specified, the OpenTelemetry exporter will auto-generate a valid ID.",
            "types": [
              "Column, optional"
            ]
          },
          {
            "ident": "span_id",
            "desc": "The column containing trace_ids, must be formatted as a lower-case hex with 16 hex characters (aka 8 bytes), or the engine will auto-generate a new ID. If not specified, the OpenTelemetry exporter will auto-generate a valid ID.",
            "types": [
              "Column, optional"
            ]
          },
          {
            "ident": "parent_span_id",
            "desc": "The column containing parent_span_ids, must be formatted as a lower-case hex with 16 hex characters (aka 8 bytes), or the engine will write the data as empty. If not specified, will leave the parent_span_id field empty.",
            "types": [
              "Column, optional"
            ]
          },
          {
            "ident": "attributes",
            "desc": "A mapping of attribute name to a string or the column that stores data about the attribute.",
            "types": [
              "Dict[string, Column|string], optional"
            ]
          },
          {
            "ident": "kind",
            "desc": "The OpenTelemetry SpanKind enum value to assign for all the spans. Defaults to SPAN_KIND_SERVER if not set.",
            "types": [
              "int, optional"
            ]
          }
        ],
        "returnType": {
          "desc": "the mapping of DataFrame columns to OpenTelemetry Span fields. Can be passed into `px.otel.Data()` as the data argument.",
          "types": [
            "OTelDataContainer"
          ]
        }
      }
    }
  ],
  "pyApiDocs": {
    "funcs": [],
    "classes": [
      {
        "def": {
          "name": "class Client",
          "declaration": "Client(self, token: str, server_url: str = 'work.withpixie.ai', use_encryption: bool = False, channel_fn: Callable[[str], grpc.Channel] = None, conn_channel_fn: Callable[[str], grpc.aio._base_channel.Channel] = None )",
          "docstring": "Client is the main entry point to the Pixie API.\n\nTo setup the client, you need to generate an API token\nand pass it in as the first argument.\nSee: https://docs.px.dev/using-pixie/api-quick-start/\nfor more info."
        },
        "methods": [
          {
            "name": "def connect_to_cluster",
            "declaration": "def connect_to_cluster(self, cluster: Union[str, pxapi.client.Cluster]) -\u003e pxapi.client.Conn",
            "docstring": "Connect to a cluster.\n\nReturns a connection object that you can use to create `ScriptExecutor`s.\nYou may pass in a `ClusterID` string or a `Cluster` object that comes\nfrom `list_healthy_clusters()`."
          },
          {
            "name": "def list_healthy_clusters",
            "declaration": "def list_healthy_clusters(self) -\u003e List[pxapi.client.Cluster]",
            "docstring": "Lists all of the healthy clusters that you can access."
          }
        ]
      },
      {
        "def": {
          "name": "class Cluster",
          "declaration": "Cluster(self, cluster_id: str, cluster_info: src.api.proto.cloudpb.cloudapi_pb2.ClusterInfo )",
          "docstring": "Cluster contains information users need about a specific cluster.\n\nMainly a convenience wrapper around the protobuf message so you\ncan access the name in a simple format."
        },
        "methods": [
          {
            "name": "def name",
            "declaration": "def name(self) -\u003e str",
            "docstring": "Returns the name if that info exists, otherwise returns the id."
          }
        ]
      },
      {
        "def": {
          "name": "class Conn",
          "declaration": "Conn(self, token: str, pixie_url: str, cluster_id: str, use_encryption: bool = True, cluster_info: src.api.proto.cloudpb.cloudapi_pb2.ClusterInfo = None, channel_fn: Callable[[str], grpc.aio._base_channel.Channel] = None )",
          "docstring": "The logical representation of a connection.\n\nHolds the authorization information and handles the creation\nof an authorized gRPC channel."
        },
        "methods": [
          {
            "name": "def name",
            "declaration": "def name(self) -\u003e str",
            "docstring": "Get the name of the cluster for this connection."
          },
          {
            "name": "def prepare_script",
            "declaration": "def prepare_script(self, script_str: str) -\u003e pxapi.client.ScriptExecutor",
            "docstring": "Create a new ScriptExecutor for the script to run on this connection."
          }
        ]
      },
      {
        "def": {
          "name": "class ScriptExecutor",
          "declaration": "ScriptExecutor(self, conn: pxapi.client.Conn, pxl: str, use_encryption: bool)",
          "docstring": "ScriptExecutor encapsulates the connection logic to Pixie instances.\n\nIf you want to get Pixie data, you will need to initialize `ScriptExecutor` with\nthe clusters and PxL script then call `results()` for the desired table name and\niterate the results.\n\nNote: you can only invoke `results()`, `run()`,and `run_async()` once on a\n`ScriptExecutor` object. If you need to exeucte a script multiple times,\nyou must create a new `ScriptExecutor` object and setup any data processing\nagain. We rely on iterators that must close when a script stops running\nand cannot allow multiple runs per object."
        },
        "methods": [
          {
            "name": "def add_callback",
            "declaration": "def add_callback(self, table_name: str, fn: Callable[[pxapi.data.Row], NoneType]) -\u003e None",
            "docstring": "Adds a callback fn that will be invoked on every row of `table_name` as\nthey arrive.\n\nCallbacks are not invoked until you call `run()` (or `run_async()`) on\nthe object.\n\nIf you `add_callback` on a table not produced by the script, `run()`(or `run_async()`) will\nraise a ValueError when the underlying gRPC channel closes.\n\nThe internals of `ScriptExecutor` use the python async api and the callback `fn`\nwill be called concurrently while the ScriptExecutor is running. Note that callbacks\nthemselves should not be async functions.\n\nCallbacks will block the rest of script execution so expensive and unending\ncallbacks should not be used.\n\nRaises:\n    ValueError: If called on a table that's already been passed as arg to\n        `subscribe` or `add_callback`.\n    ValueError: If called after `run()` or `run_async()` for a particular\n        `ScriptExecutor`"
          },
          {
            "name": "def results",
            "declaration": "def results(self, table_name: str) -\u003e Generator[pxapi.data.Row, NoneType, NoneType]",
            "docstring": "Runs script and return results for the table.\nExamples:\n    for row in script.results(\"http_table\"):\n        print(row)\nRaises:\n    ValueError: If `table_name` is never sent during lifetime of script.\n    ValueError: If called after `run()` or `run_async()` for a particular\n        `ScriptExecutor`."
          },
          {
            "name": "def run",
            "declaration": "def run(self) -\u003e None",
            "docstring": "Executes the script synchronously.\n\nCalls `run_async()` but hides the asyncio details from users.\nIf any errors occur over the lifetime of any connection, this will raise an error.\n\nRaises:\n    ValueError: If any callbacks are on tables that a `ScriptExecutor` never receives.\n    ValueError: If called after `run()` or `run_async()` for a particular\n        `ScriptExecutor`."
          },
          {
            "name": "def run_async",
            "declaration": "def run_async(self) -\u003e None",
            "docstring": "Runs the script asynchronously using asyncio.\n\nSame as `run()` except you can directly control whether other tasks\nshould be run concurrently while the script  is running.\n\nRaises:\n    ValueError: If any callbacks are on tables that a `ScriptExecutor` never receives.\n    ValueError: If called after `run()` or `run_async()` for a particular\n        `ScriptExecutor`."
          },
          {
            "name": "def subscribe",
            "declaration": "def subscribe(self, table_name: str) -\u003e pxapi.client.TableSub",
            "docstring": "Returns an async generator that outputs rows for the table.\n\nRaises:\n    ValueError: If called on a table that's already been passed as arg to\n        `subscribe` or `add_callback`.\n    ValueError: If called after `run()` or `run_async()` for a particular\n        `ScriptExecutor`"
          },
          {
            "name": "def subscribe_all_tables",
            "declaration": "def subscribe_all_tables(self) -\u003e Callable[[], AsyncGenerator[pxapi.client.TableSub, NoneType]]",
            "docstring": "Returns an async generator that outputs table subscriptions as they arrive.\n\nYou can use this generator to call PxL scripts without knowing the tables\nthat are output beforehand. If you do know the tables beforehand, you should\n`subscribe`, `add_callback` or even `results` instead to prevent your api from\nkeeping data for tables that you don't use.\n\nThis generator will only start iterating after `run_async()` has been\ncalled. For the best performance, you will want to call the consumer of\nthe object returned by `subscribe_all_tables` concurrently with `run_async()`"
          }
        ]
      },
      {
        "def": {
          "name": "class TableSub",
          "declaration": "TableSub(self, name: str, table_gen: AsyncGenerator[Union[pxapi.data._TableStream, Literal['ERROR']], NoneType] )",
          "docstring": "TableSub is an async generator that yields rows for table.\n\nYou should avoid directly initializing TableSub objects. Instead, you\nshould create a ScriptExecutor object and `ScriptExecutor.subscribe()` to a specific table or\n`ScriptExecutor.subscribe_all_tables()`. This avoids the complexity involved in creating this\nobject.\n\nFor more advanced users: the TableSub object is a promise that a table with the specified name\nwill be yielded by the `table_gen`. If the table does not get yielded, the async generator will\nthrow an error when the `table_gen` exits."
        },
        "methods": []
      },
      {
        "def": {
          "name": "class Row",
          "declaration": "Row(self, table: pxapi.data._TableStream, data: List[Any])",
          "docstring": "Row represents a row of data for a particular table. You can easily access\ndata in the row by using the column name from the associated table.\n\nSpecifically designed to avoid allocation memory for the relation for each row.\n\nExamples:\n  \u003e\u003e\u003e tableA = Table(\"a\", relation=((\"cola\",int), (\"colb\", int), (\"colc\", string)))\n  \u003e\u003e\u003e row = Row(tableA, [1,2,\"three\"])\n  \u003e\u003e\u003e row[\"cola\"]\n  1\n  \u003e\u003e\u003e row[\"colb\"]\n  2\n  \u003e\u003e\u003e row[\"colc\"]\n  \"three\"\n  \u003e\u003e\u003e row\n  { \"cola\": 1, \"colb\": 2, \"colc\": \"three\" }"
        },
        "methods": []
      },
      {
        "def": {
          "name": "class CryptoOptions",
          "declaration": "CryptoOptions(self)",
          "docstring": ""
        },
        "methods": [
          {
            "name": "def encrypt_options",
            "declaration": "def encrypt_options(self) -\u003e src.api.proto.vizierpb.vizierapi_pb2.EncryptionOptions",
            "docstring": ""
          }
        ]
      }
    ]
  },
  "tracepointDecoratorDocs": [
    {
      "body": {
        "name": "pxtrace.probe",
        "brief": "Decorates a tracepoint definition.",
        "desc": "Specifies the decorated function as a tracepoint on the `trace_fn` name. Automatically figures out the language based on the functon specified.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "trace_fn",
            "desc": "The func to trace. For go, the format is `\u003cpackage_name\u003e.\u003cfunc_name\u003e`.",
            "types": [
              "str"
            ]
          }
        ],
        "returnType": {
          "desc": "The wrapped probe function.",
          "types": [
            "Func"
          ]
        }
      }
    }
  ],
  "tracepointFieldDocs": [
    {
      "body": {
        "name": "pxtrace.ArgExpr",
        "brief": "Specifies a function argument to trace.",
        "desc": "Extracts the function argument, as specified by the provided expression. Traceable types are base types (`int`, `float`, etc.), strings and byte arrays. Base-type arguments are specified directly (`arg1`), while struct members are accessed using dotted notation (`arg1.foo`). The dot operator works on both pointer and non-pointer types.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "expr",
            "desc": "The expression to evaluate.",
            "types": [
              "str"
            ]
          }
        ],
        "returnType": {
          "desc": "A materialized column pointer to use in output table definitions.",
          "types": [
            "px.TracingField"
          ]
        }
      }
    },
    {
      "body": {
        "name": "pxtrace.FunctionLatency",
        "brief": "Specifies a function latency to trace.",
        "desc": "Computes the function latency, from entry to return. The measured latency includes includes time spent in sub-calls.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [],
        "returnType": {
          "desc": "A materialized column pointer to use in output table definitions.",
          "types": [
            "px.TracingField"
          ]
        }
      }
    },
    {
      "body": {
        "name": "pxtrace.LabelSelector",
        "brief": "Creates a Tracepoint target for a process.",
        "desc": "Defines a tracepoint target for a process based a set of k8s labels representing a set of pods matching all of this labels. Optionally, a container and process can be provided.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "labels",
            "desc": "The K8s labels that can be resolved to a set of pods. Must be of a dictionary of key value pairs.",
            "types": [
              "dict\u003cstr, str\u003e"
            ]
          },
          {
            "ident": "namespace",
            "desc": "The namespace that target pods are in.",
            "types": [
              "str"
            ]
          },
          {
            "ident": "container_name",
            "desc": "The name of the container that's running the process. Specify this argument if a pod has more than one containers. The compiler will error out if a pod has multiple containers and this is not specified.",
            "types": [
              "str, optional"
            ]
          },
          {
            "ident": "process_name",
            "desc": "A regexp that matches any substrings of the command line of the target process. Specify this if a container has more than one process. The compiler will error out if a container has multiple processes and this is not specified.",
            "types": [
              "str, optional"
            ]
          }
        ],
        "returnType": {
          "desc": "A pointer to that Process that can be passed as a target to UpsertTracepoint.",
          "types": [
            "ProcessTarget"
          ]
        }
      }
    },
    {
      "body": {
        "name": "pxtrace.PodProcess",
        "brief": "Creates a Tracepoint target for a process.",
        "desc": "Defines a tracepoint target for a process based on the pod and if that's not specific enough a container and process path.  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "pod_name",
            "desc": "The name of the pod running the target process. Must be of the format \u003cnamespace\u003e/\u003cpod\u003e. You may also use the prefix of the pod name to avoid writing the kubernetes generated check-sum.",
            "types": [
              "str"
            ]
          },
          {
            "ident": "container_name",
            "desc": "The name of the container that's running the process. Specify this argument if a pod has more than one containers. The compiler will error out if a pod has multiple containers and this is not specified.",
            "types": [
              "str, optional"
            ]
          },
          {
            "ident": "process_name",
            "desc": "A regexp that matches any substrings of the command line of the target process. Specify this if a container has more than one process. The compiler will error out if a container has multiple processes and this is not specified.",
            "types": [
              "str, optional"
            ]
          }
        ],
        "returnType": {
          "desc": "A pointer to that Process that can be passed as a target to UpsertTracepoint.",
          "types": [
            "ProcessTarget"
          ]
        }
      }
    },
    {
      "body": {
        "name": "pxtrace.RetExpr",
        "brief": "Specifies a function return value to trace.",
        "desc": "Extracts data from the function return value, as specified by the provided expression. Traceable types are the same as in `ArgExpr`. Return values are accessed by index (`$0` for the first return value, `$1` for the second return value, etc.). In Golang, the first index value is the number of arguments, excluding the receiver. For example, the return value for `fun Sum(a int, b int) int` is `$2`. Return values that are structs may be accessed using dotted notation, similar to `ArgExpr`, (e.g. `$0.foo`).  ",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "expr",
            "desc": "The expression to evaluate.",
            "types": [
              "str"
            ]
          }
        ],
        "returnType": {
          "desc": "A materialized column pointer to use in output table definitions.",
          "types": [
            "px.TracingField"
          ]
        }
      }
    },
    {
      "body": {
        "name": "pxtrace.SharedObject",
        "brief": "Defines a shared object target for Tracepoints.",
        "examples": []
      },
      "funcDoc": {
        "args": [
          {
            "ident": "name",
            "desc": "The name of the shared object.",
            "types": [
              "str"
            ]
          },
          {
            "ident": "upid",
            "desc": "A process which loads the shared object.",
            "types": [
              "px.UPID"
            ]
          }
        ],
        "returnType": {
          "desc": "A pointer to the SharedObject that can be passed as a target to UpsertTracepoint.",
          "types": [
            "SharedObject"
          ]
        }
      }
    },
    {
      "body": {
        "name": "pxtrace.kprobe",
        "brief": "Defines a kprobe target for an UpsertTracepoint.",
        "examples": []
      },
      "funcDoc": {
        "args": [],
        "returnType": {
          "desc": "KProbe target that can be passed into UpsertTracepoint.",
          "types": [
            "KProbeTarget"
          ]
        }
      }
    }
  ],
  "udfDocs": {
    "udf": [
      {
        "name": "_exec_host_num_cpus",
        "brief": "Get the number of CPUs on the host machine.",
        "desc": "Get the number of CPUs on the machine where the function is executed.",
        "examples": [
          {
            "value": "```\ndf.num_cpus = px._exec_host_num_cpus()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The number of CPUs of the host machine.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "_exec_hostname",
        "brief": "Get the hostname of the machine.",
        "desc": "Get the hostname of the machine that the data originated from.",
        "examples": [
          {
            "value": "```\ndf.hostname = px._exec_hostname()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The hostname of the machine.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "_match_regex_rule",
        "brief": "Check for a match to a json of regex pattern rules in a string.",
        "desc": "This function checks the input string (second arg) for a match with the regex pattern rules(first arg). The regex pattern must match the full string. For example, the pattern 'abc' doesn't match the string 'abcd' but the pattern 'abc*' does match that string. We support google RE2 syntax. More details on that syntax can be found [here](https://github.com/google/re2/wiki/Syntax). ",
        "examples": [
          {
            "value": "```\ndf.is_match = px.regex_match('{\"rule1\": \".*my_regex_pattern.*\"}', df.resp_body)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The encoded json map from the name of the rule to the regex pattern for the rule.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The string column to match the pattern against.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "string representing the name of the first rule that matched or an empty string if no match.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "abs",
        "brief": "Computes absolute value",
        "desc": "Computes the absolute value",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value abs(v)",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "abs",
        "brief": "Computes absolute value",
        "desc": "Computes the absolute value",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value abs(v)",
            "type": "INT64"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "FLOAT64"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "STRING"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "FLOAT64"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "TIME64NS"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "add",
        "brief": "Arithmetically add the arguments or concatenate the strings.",
        "desc": "This function is implicitly invoked by the + operator.\n      If both types are strings, then will concate the strings. Trying to\n      add any other type to a string will cause an error",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.sum = df.a + df.b\nExplicit call.\ndf.sum = px.add(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be added to.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The value to add to the first argument.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "The sum of a and b.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "amqp_frame_type_name",
        "brief": "Convert a AMQP frame type to its name.",
        "desc": "UDF to convert AMQP frame type into their corresponding human-readable names.",
        "examples": [
          {
            "value": "```\ndf.frame_type_name = px.amqp_frame_type_name(df.req_cmd)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "frame_type",
              "desc": "An AMQP frame_type in numeric value",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The AMQP Frame Type name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "amqp_method_name",
        "brief": "Convert a AMQP method id to its name.",
        "desc": "UDF to convert AMQP method id into their corresponding human-readable names.",
        "examples": [
          {
            "value": "```\ndf.method_name = px.amqp_method_name(df.class_id, df.method_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "class_id",
              "desc": "An AMQP class_id in numeric value",
              "type": "INT64"
            },
            {
              "ident": "method_id",
              "desc": "An AMQP method_id in numeric value",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The AMQP Method name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "any",
        "brief": "Picks any single value.",
        "desc": "Picks a value from the collection. No guarantees on which value is picked.",
        "examples": [
          {
            "value": "```\n# Calculate any value from the collection.\ndf = df.agg(latency_dist=('val', px.any))\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to select the value from.",
              "type": "BOOLEAN"
            }
          ],
          "result": {
            "desc": "The a single record selected from the above val.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "any",
        "brief": "Picks any single value.",
        "desc": "Picks a value from the collection. No guarantees on which value is picked.",
        "examples": [
          {
            "value": "```\n# Calculate any value from the collection.\ndf = df.agg(latency_dist=('val', px.any))\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to select the value from.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The a single record selected from the above val.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "any",
        "brief": "Picks any single value.",
        "desc": "Picks a value from the collection. No guarantees on which value is picked.",
        "examples": [
          {
            "value": "```\n# Calculate any value from the collection.\ndf = df.agg(latency_dist=('val', px.any))\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to select the value from.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The a single record selected from the above val.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "any",
        "brief": "Picks any single value.",
        "desc": "Picks a value from the collection. No guarantees on which value is picked.",
        "examples": [
          {
            "value": "```\n# Calculate any value from the collection.\ndf = df.agg(latency_dist=('val', px.any))\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to select the value from.",
              "type": "TIME64NS"
            }
          ],
          "result": {
            "desc": "The a single record selected from the above val.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "any",
        "brief": "Picks any single value.",
        "desc": "Picks a value from the collection. No guarantees on which value is picked.",
        "examples": [
          {
            "value": "```\n# Calculate any value from the collection.\ndf = df.agg(latency_dist=('val', px.any))\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to select the value from.",
              "type": "STRING"
            }
          ],
          "result": {
            "desc": "The a single record selected from the above val.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "any",
        "brief": "Picks any single value.",
        "desc": "Picks a value from the collection. No guarantees on which value is picked.",
        "examples": [
          {
            "value": "```\n# Calculate any value from the collection.\ndf = df.agg(latency_dist=('val', px.any))\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to select the value from.",
              "type": "UINT128"
            }
          ],
          "result": {
            "desc": "The a single record selected from the above val.",
            "type": "UINT128"
          }
        }
      },
      {
        "name": "approxEqual",
        "brief": "Return whether the two values are approximately equal.",
        "desc": "Returns whether or not the two given values are approximately equal to each other, where the values have an absolute difference of less than 1E-9.",
        "examples": [
          {
            "value": "```\ndf.equals = px.approxEqual(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "FLOAT64"
            },
            {
              "ident": "arg2",
              "desc": "The value which should be compared to the first argument.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Boolean of whether the two arguments are approximately equal.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "asid",
        "brief": "Get the agent ID.",
        "desc": "Get the agent ID of the node that the data originated from.",
        "examples": [
          {
            "value": "```\ndf.agent = px.asid()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The agent ID.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "atoi",
        "brief": "Convert a string to an integer.",
        "desc": "This function parses a string into a 64-bit integer if possible, otherwise it returns the default value.",
        "examples": [
          {
            "value": "```\ndf.val = px.atoi(df.int_as_str_col, -1)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The string to convert",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The default integer value to return if conversion fails",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Integer version of string, if parsing succeeded otherwise the default value passed in.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "bin",
        "brief": "Rounds value to the nearest multiple.",
        "desc": "Takes the passed in value(s) and bin them to the nearest multiple of a bin.",
        "examples": [
          {
            "value": "```\n# bin column b to multiples of 50\ndf.a = px.bin(df.b, 50)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to bin.",
              "type": "INT64"
            },
            {
              "ident": "bin",
              "desc": "The bin value to clip to.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value rounded down to the nearest multiple of bin.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "bin",
        "brief": "Rounds value to the nearest multiple.",
        "desc": "Takes the passed in value(s) and bin them to the nearest multiple of a bin.",
        "examples": [
          {
            "value": "```\n# bin column b to multiples of 50\ndf.a = px.bin(df.b, 50)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to bin.",
              "type": "TIME64NS"
            },
            {
              "ident": "bin",
              "desc": "The bin value to clip to.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "The value rounded down to the nearest multiple of bin.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "bin",
        "brief": "Rounds value to the nearest multiple.",
        "desc": "Takes the passed in value(s) and bin them to the nearest multiple of a bin.",
        "examples": [
          {
            "value": "```\n# bin column b to multiples of 50\ndf.a = px.bin(df.b, 50)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to bin.",
              "type": "INT64"
            },
            {
              "ident": "bin",
              "desc": "The bin value to clip to.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "The value rounded down to the nearest multiple of bin.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "bin",
        "brief": "Rounds value to the nearest multiple.",
        "desc": "Takes the passed in value(s) and bin them to the nearest multiple of a bin.",
        "examples": [
          {
            "value": "```\n# bin column b to multiples of 50\ndf.a = px.bin(df.b, 50)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to bin.",
              "type": "TIME64NS"
            },
            {
              "ident": "bin",
              "desc": "The bin value to clip to.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value rounded down to the nearest multiple of bin.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "bin",
        "brief": "Rounds value to the nearest multiple.",
        "desc": "Takes the passed in value(s) and bin them to the nearest multiple of a bin.",
        "examples": [
          {
            "value": "```\n# bin column b to multiples of 50\ndf.a = px.bin(df.b, 50)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to bin.",
              "type": "FLOAT64"
            },
            {
              "ident": "bin",
              "desc": "The bin value to clip to.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value rounded down to the nearest multiple of bin.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "bytes_to_hex",
        "brief": "Convert an input bytes in hex string.",
        "desc": "This function converts an input bytes sequence in hex string.",
        "examples": [
          {
            "value": "```\ndf.hex = px.bytes_to_hex(df.resp)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The bytes sequence.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The input converted to a hex string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "ceil",
        "brief": "Compute the ceiling of the value.",
        "examples": [
          {
            "value": "```\ndf.b = px.ceil(df.a)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to take the ceiling of.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The ceiling of arg1.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "cidrs_contain_ip",
        "brief": "Determine whether an IP is contained in a set of CIDR ranges.",
        "desc": "Determine whether the given IP is within anyone of the CIDR ranges provided. For example, 10.0.0.1 is contained in the CIDR range 10.0.0.0/24.",
        "examples": [
          {
            "value": "```\ndf.cluster_cidrs = px.get_cidrs()| df.ip_is_in_cluster = px.cidrs_contain_ip(df.cluster_cidrs, df.remote_addr)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "cidrs",
              "desc": "Json array of CIDR ranges, where each CIDR range is a string of format '\u003cIP\u003e/\u003cprefix_length\u003e'",
              "type": "STRING"
            },
            {
              "ident": "ip_addr",
              "desc": "IP address to check for presence in range.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "boolean representing whether the given IP is in any one of the given CIDR ranges.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "container_id_to_start_time",
        "brief": "Get the start time of a container from its ID.",
        "desc": "Gets the start time (in nanosecond unix time format) of a container from its container ID.",
        "examples": [
          {
            "value": "```\ndf.container_start_time = px.container_id_to_start_time(df.container_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "container_id",
              "desc": "The Container ID of the Container to get the start time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Container ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "container_id_to_status",
        "brief": "Get the status of the container given the container ID.",
        "desc": "Get the status of the container given the container ID. The status is the K8s state of either 'Running', 'Waiting', 'Terminated' or 'Unknown'. It may be paired with additional information such as a message and reason explaining why the container is in that state.",
        "examples": [
          {
            "value": "```\ndf.status = px.container_id_to_status(df.id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "id",
              "desc": "The ID of the container to get the status of.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The status of the container.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "container_id_to_stop_time",
        "brief": "Get the stop time of a container from its ID.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a container from its container ID.",
        "examples": [
          {
            "value": "```\ndf.container_stop_time = px.container_id_to_stop_time(df.container_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "container_id",
              "desc": "The Container ID of the Container to get the stop time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Container ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "container_name_to_container_id",
        "brief": "Get the id of a container from its name.",
        "desc": "Gets the kubernetes ID for the container from its name.",
        "examples": [
          {
            "value": "```\ndf.container_id = px.container_name_to_container_id(df.container_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "container_name",
              "desc": "The name of the container to get the ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s container ID for the container name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "container_name_to_start_time",
        "brief": "Get the start time of a container from its name.",
        "desc": "Gets the start time (in nanosecond unix time format) of a container from its name.",
        "examples": [
          {
            "value": "```\ndf.container_start_time = px.container_name_to_start_time(df.container_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "container_name",
              "desc": "The name of the Container to get the start time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Container name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "container_name_to_stop_time",
        "brief": "Get the stop time of a container from its name.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a container from its name.",
        "examples": [
          {
            "value": "```\ndf.container_stop_time = px.container_name_to_stop_time(df.container_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "container_name",
              "desc": "The name of the Container to get the stop time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Container name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "contains",
        "brief": "Returns whether the first string contains the second string.",
        "examples": [
          {
            "value": "```\nmatching_df = matching_df[px.contains(matching_df.svc_names, 'my_svc')]\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The string that should contain the second string.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The string that should be contained in the first string.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "A boolean of whether the first string contains the second string.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "count",
        "brief": "Returns number of rows in the aggregate group.",
        "desc": "This function counts the number of rows in the aggregate group. The count of rows is independent of which column this function is applied to. Each column should return the same number of rows.",
        "examples": [
          {
            "value": "```\ndf = df.agg(throughput_total=('latency_ms', px.count))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The count.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "count",
        "brief": "Returns number of rows in the aggregate group.",
        "desc": "This function counts the number of rows in the aggregate group. The count of rows is independent of which column this function is applied to. Each column should return the same number of rows.",
        "examples": [
          {
            "value": "```\ndf = df.agg(throughput_total=('latency_ms', px.count))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The count.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "count",
        "brief": "Returns number of rows in the aggregate group.",
        "desc": "This function counts the number of rows in the aggregate group. The count of rows is independent of which column this function is applied to. Each column should return the same number of rows.",
        "examples": [
          {
            "value": "```\ndf = df.agg(throughput_total=('latency_ms', px.count))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "TIME64NS"
            }
          ],
          "result": {
            "desc": "The count.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "count",
        "brief": "Returns number of rows in the aggregate group.",
        "desc": "This function counts the number of rows in the aggregate group. The count of rows is independent of which column this function is applied to. Each column should return the same number of rows.",
        "examples": [
          {
            "value": "```\ndf = df.agg(throughput_total=('latency_ms', px.count))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "BOOLEAN"
            }
          ],
          "result": {
            "desc": "The count.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "count",
        "brief": "Returns number of rows in the aggregate group.",
        "desc": "This function counts the number of rows in the aggregate group. The count of rows is independent of which column this function is applied to. Each column should return the same number of rows.",
        "examples": [
          {
            "value": "```\ndf = df.agg(throughput_total=('latency_ms', px.count))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "STRING"
            }
          ],
          "result": {
            "desc": "The count.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "count",
        "brief": "Returns number of rows in the aggregate group.",
        "desc": "This function counts the number of rows in the aggregate group. The count of rows is independent of which column this function is applied to. Each column should return the same number of rows.",
        "examples": [
          {
            "value": "```\ndf = df.agg(throughput_total=('latency_ms', px.count))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "UINT128"
            }
          ],
          "result": {
            "desc": "The count.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "cql_opcode_name",
        "brief": "Convert a CQL op code to its name.",
        "desc": "UDF to convert CQL request opcodes into their corresponding names.",
        "examples": [
          {
            "value": "```\ndf.cmd = px.cql_opcode_name(df.req_op)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "req_op",
              "desc": "A CQL opcode",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The request opcode's name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_id_to_deployment_name",
        "brief": "Get the Deployment Name from a Deployment ID.",
        "desc": "Gets the Kubernetes Deployment Name for the Deployment ID.If the given ID doesn't have an associated Kubernetes Deployment, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.deployment_name = px.deployment_id_to_deployment_name(deployment_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_id",
              "desc": "The ID of the Deployment to get the name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Deployment Name for the ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_id_to_namespace",
        "brief": "Get the namespace of a Deployment from its ID.",
        "desc": "Gets the namespace of a Deployment from its ID.",
        "examples": [
          {
            "value": "```\ndf.namespace = px.deployment_id_id_to_namespace(deployment_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_id",
              "desc": "The Deployment ID of the Deployment to get the namespace for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The namespace for the Deployment ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_id_to_start_time",
        "brief": "Get the start time of a Deployment from its ID.",
        "desc": "Gets the start time (in nanosecond unix time format) of a Deployment from its ID.",
        "examples": [
          {
            "value": "```\ndf.deployment_start_time = px.deployment_id_to_start_time(deployment_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_id",
              "desc": "The Deployment ID of the Deployment to get the start time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Deployment ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "deployment_id_to_status",
        "brief": "Get the status of a Deployment from its ID.",
        "desc": "Gets the status of a Deployment from its ID.",
        "examples": [
          {
            "value": "```\ndf.status = px.deployment_id_to_status(deployment_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_id",
              "desc": "The Deployment ID of the Deployment to get the status for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The status for the Deployment ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_id_to_stop_time",
        "brief": "Get the stop time of a Deployment from its ID.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a Deployment from its ID.",
        "examples": [
          {
            "value": "```\ndf.deployment_stop_time = px.deployment_id_to_stop_time(deployment_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_id",
              "desc": "The Deployment ID of the Deployment to get the stop time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Deployment ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "deployment_name_to_deployment_id",
        "brief": "Get the Deployment ID from a Deployment name.",
        "desc": "Gets the Kubernetes Deployment ID for the Deployment name.If the given name doesn't have an associated Kubernetes Deployment, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.deployment_id = px.deployment_name_to_deployment_id(deployment_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_name",
              "desc": "The name of the Deployment to get the ID for. The name includes the namespace of the Deployment. i.e. \"ns/deployment_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Deployment ID for the name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_name_to_namespace",
        "brief": "Get the namespace of a Deployment from its name.",
        "desc": "Gets the namespace of a Deployment from its name.",
        "examples": [
          {
            "value": "```\ndf.namespace = px.deployment_name_to_namespace(deployment_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_name",
              "desc": "The name of the Deployment to get the name for. The name includes the namespace of the Deployment. i.e. \"ns/deployment_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The namespace for the Deployment name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_name_to_start_time",
        "brief": "Get the start time of a Deployment from its name.",
        "desc": "Gets the start time (in nanosecond unix time format) of a Deployment from its name.",
        "examples": [
          {
            "value": "```\ndf.deployment_start_time = px.deployment_id_to_start_time(deployment_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_name",
              "desc": "The name of the Deployment to get the name for. The name includes the namespace of the Deployment. i.e. \"ns/deployment_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Deployment name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "deployment_name_to_status",
        "brief": "Get the status of a Deployment from its name.",
        "desc": "Gets the status of a Deployment from its name.",
        "examples": [
          {
            "value": "```\ndf.status = px.deployment_id_to_status(deployment_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_name",
              "desc": "The name of the Deployment to get the name for. The name includes the namespace of the Deployment. i.e. \"ns/deployment_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The status for the Deployment name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "deployment_name_to_stop_time",
        "brief": "Get the stop time of a Deployment from its name.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a Deployment from its name.",
        "examples": [
          {
            "value": "```\ndf.deployment_stop_time = px.deployment_name_to_stop_time(deployment_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "deployment_name",
              "desc": "The name of the Deployment to get the name for. The name includes the namespace of the Deployment. i.e. \"ns/deployment_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Deployment name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "divide",
        "brief": "Arithmetically divide the two arguments.",
        "desc": "This function is implicitly invoked by the / operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.div = df.a / df.b\n# Explicit call.\ndf.div = px.divide(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to divide.",
              "type": "INT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to divide the first argument by.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value of arg1 divided by arg2.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "divide",
        "brief": "Arithmetically divide the two arguments.",
        "desc": "This function is implicitly invoked by the / operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.div = df.a / df.b\n# Explicit call.\ndf.div = px.divide(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to divide.",
              "type": "FLOAT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to divide the first argument by.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value of arg1 divided by arg2.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "divide",
        "brief": "Arithmetically divide the two arguments.",
        "desc": "This function is implicitly invoked by the / operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.div = df.a / df.b\n# Explicit call.\ndf.div = px.divide(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to divide.",
              "type": "INT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to divide the first argument by.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value of arg1 divided by arg2.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "divide",
        "brief": "Arithmetically divide the two arguments.",
        "desc": "This function is implicitly invoked by the / operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.div = df.a / df.b\n# Explicit call.\ndf.div = px.divide(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to divide.",
              "type": "FLOAT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to divide the first argument by.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value of arg1 divided by arg2.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "dns_rcode_name",
        "brief": "Convert a DNS rcode to its name.",
        "desc": "UDF to convert DNS rcodes into their corresponding names.",
        "examples": [
          {
            "value": "```\ndf.rcode_name = px.dns_rcode_name(df.rcode)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "rcode",
              "desc": "A DNS rcode",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The request opcode's name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "STRING"
            },
            {
              "ident": "b2",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "BOOLEAN"
            },
            {
              "ident": "b2",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "TIME64NS"
            },
            {
              "ident": "b2",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "UINT128"
            },
            {
              "ident": "b2",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "BOOLEAN"
            },
            {
              "ident": "b2",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Returns whether the values are equal.",
        "desc": "Determines whether the values are equal. Passing in floating-point values might lead to false negatives. Use `px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.success_http = df.http_status == 200\n# Explicit call.\ndf.success_http = px.equal(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "FLOAT64"
            },
            {
              "ident": "b2",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "equal",
        "brief": "Return whether the two values are approximately equal.",
        "desc": "Returns whether or not the two given values are approximately equal to each other, where the values have an absolute difference of less than 1E-9.",
        "examples": [
          {
            "value": "```\ndf.equals = px.approxEqual(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "FLOAT64"
            },
            {
              "ident": "arg2",
              "desc": "The value which should be compared to the first argument.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Boolean of whether the two arguments are approximately equal.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "exp",
        "brief": "Computes e^x",
        "desc": "Computes the power function x^y, with base = e",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "y",
              "desc": "The exponent",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value e^y",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "exp",
        "brief": "Computes e^x",
        "desc": "Computes the power function x^y, with base = e",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "y",
              "desc": "The exponent",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value e^y",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "find",
        "brief": "Find the index of the first occurrence of the substring.",
        "desc": "Returns the index of the first occurrence of the substring in the given string. If no match is found, returns -1.",
        "examples": [
          {
            "value": "```\ndf.svc_name = \"pixie-labs\"\ndf.found = px.find(df.svc_name, '-labs') # 5\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The string to search through.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The substring to find.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The index of the first occurence of the substring. -1 if no match is found.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "floor",
        "brief": "Compute the floor of the value.",
        "examples": [
          {
            "value": "```\ndf.b = px.floor(df.a)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to take the floor of.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The floor of arg1.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "get_cidrs",
        "brief": "Get the pod/service CIDRs for the cluster.",
        "desc": "Get a json-encoded array of pod/service CIDRs for the cluster in 'ip/prefix_length' format. Including CIDRs that include the CNI bridge for pods.",
        "examples": [
          {
            "value": "```\ndf.cidrs = px.get_cidrs()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The pod and/or service CIDRs for this cluster, encoded as a json array.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "greaterThan",
        "brief": "Compare whether the first argument is greater than the second argument.",
        "desc": "This function is implicitly invoked by the \u003e operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gt = df.a \u003e df.b\nExplicit call.\ndf.gt = px.greaterThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "INT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than the first argument.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThan",
        "brief": "Compare whether the first argument is greater than the second argument.",
        "desc": "This function is implicitly invoked by the \u003e operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gt = df.a \u003e df.b\nExplicit call.\ndf.gt = px.greaterThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "TIME64NS"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than the first argument.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThan",
        "brief": "Compare whether the first argument is greater than the second argument.",
        "desc": "This function is implicitly invoked by the \u003e operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gt = df.a \u003e df.b\nExplicit call.\ndf.gt = px.greaterThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "FLOAT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than the first argument.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThan",
        "brief": "Compare whether the first argument is greater than the second argument.",
        "desc": "This function is implicitly invoked by the \u003e operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gt = df.a \u003e df.b\nExplicit call.\ndf.gt = px.greaterThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than the first argument.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThanEqual",
        "brief": "Compare whether the first argument is greater than or equal to the second argument.",
        "desc": "This function is implicitly invoked by the \u003e= operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gte = df.a \u003e= df.b\nExplicit call.\ndf.gte = px.greaterThanEqual(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "INT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than or equal to the first argument.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than or equal to arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThanEqual",
        "brief": "Compare whether the first argument is greater than or equal to the second argument.",
        "desc": "This function is implicitly invoked by the \u003e= operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gte = df.a \u003e= df.b\nExplicit call.\ndf.gte = px.greaterThanEqual(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "FLOAT64"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than or equal to the first argument.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than or equal to arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThanEqual",
        "brief": "Compare whether the first argument is greater than or equal to the second argument.",
        "desc": "This function is implicitly invoked by the \u003e= operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gte = df.a \u003e= df.b\nExplicit call.\ndf.gte = px.greaterThanEqual(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than or equal to the first argument.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than or equal to arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "greaterThanEqual",
        "brief": "Compare whether the first argument is greater than or equal to the second argument.",
        "desc": "This function is implicitly invoked by the \u003e= operator.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.gte = df.a \u003e= df.b\nExplicit call.\ndf.gte = px.greaterThanEqual(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to be compared to.",
              "type": "TIME64NS"
            },
            {
              "ident": "arg2",
              "desc": "The value to check if it is greater than or equal to the first argument.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "Boolean of whether arg1 is greater than or equal to arg2.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "grpc_status_code_to_str",
        "brief": "Converts the GRPC status code into a readable string error.",
        "examples": [
          {
            "value": "```\ndf.err_reason = px.grpc_status_code_to_str(12)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "status_code",
              "desc": "The GRPC status code to convert.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "A string representation of the GRPC status code.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "has_service_id",
        "brief": "Determine if a particular service ID is present",
        "desc": "Checks to see if a given service ID is present. Can include matching an individual service ID, or checking against a list of service IDs.",
        "examples": [
          {
            "value": "```\ndf = df[px.has_service_id(df.ctx[\"service_id\"], \"c5f103ab-349e-49e4-8162-3b74f2c07693\")]\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service_id",
              "desc": "The service ID to check",
              "type": "STRING"
            },
            {
              "ident": "value",
              "desc": "The value to check for in service",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "True if value is present in service_id, otherwise false",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "has_service_name",
        "brief": "Determine if a particular service name is present",
        "desc": "Checks to see if a given service is present. Can include matching an individual service, or checking against a list of services.",
        "examples": [
          {
            "value": "```\ndf = df[px.has_service_name(df.ctx[\"service\"], \"kube-system/kube-dns\")]\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service",
              "desc": "The service to check",
              "type": "STRING"
            },
            {
              "ident": "value",
              "desc": "The value to check for in service",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "True if value is present in service, otherwise false",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "has_value",
        "brief": "Determine if a value is present in an array.",
        "desc": "Checks to see if a given value is present in an array. Can include matching an individual value, or checking against an array of services.",
        "examples": [
          {
            "value": "```\ndf = df[px.has_value(df.ctx[\"replica_set\"], \"kube-system/kube-dns-79c57c8c9b\")]\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "array_or_value",
              "desc": "Array or value to check.",
              "type": "STRING"
            },
            {
              "ident": "value",
              "desc": "The value to check for in passed in value.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "True if value is present in the input, otherwise false.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "hex_to_ascii",
        "brief": "Convert an input hex sequence in ASCII to bytes.",
        "desc": "This function converts an input hex sequence in ASCII to bytes. The input must be a well-formed hex representation, with optional separator.If the input is invalid, it will return an empty string.",
        "examples": [
          {
            "value": "```\ndf.asciiBytes = px.hex_to_ascii(df.resp)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The ascii hex sequence to convert to bytes.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The input converted to a sequence of bytes, or empty string if invalid.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "http_resp_message",
        "brief": "Convert an HTTP response code to its corresponding message.",
        "desc": "UDF to convert HTTP response codes into their corresponding messages.",
        "examples": [
          {
            "value": "```\ndf.resp_message = px.http_resp_message(df.resp_status)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "code",
              "desc": "An HTTP response code (e.g. 404)",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The HTTP response message.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "int64_to_time",
        "brief": "Converts a int64 value to a time",
        "desc": "Converts an int64 value to a time value. Used when type-specific UDFs are needed for time on a int64 value.",
        "examples": [
          {
            "value": "```\ndf = df[px.int64_to_time(0) != df.time_]\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The int64 value to convert (in nanoseconds).",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "A time value",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "invert",
        "brief": "Invert the bits of the given value.",
        "examples": [
          {
            "value": "```\ndf.inverted = px.invert(df.a)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The value to invert.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The inverted form of arg1.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "ip_to_pod_id",
        "brief": "Convert IP address to the kubernetes pod ID that runs the backing service.",
        "desc": "Converts the IP address into a kubernetes pod ID for that IP address if it exists, otherwise returns an empty string. Converting to a pod ID means you can then extract the corresponding service name using `px.pod_id_to_service_name`.\nNote that this will not be able to convert IP addresses into DNS names generally as this is limited to internal Kubernetes state.",
        "examples": [
          {
            "value": "```\n# Convert to the Kubernetes pod ID.\ndf.pod_id = px.ip_to_pod_id(df.remote_addr)\n# Convert the ID to a readable name.\ndf.service = px.pod_id_to_service_name(df.pod_id)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_ip",
              "desc": "The IP of a pod to convert.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Kubernetes ID of the pod if it exists, otherwise an empty string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "ip_to_service_id",
        "brief": "Get the service ID for a given IP.",
        "desc": "Converts the IP address into a Kubernetes service ID for the service associated to the IP. If there is no service associated with the given IP address, return an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_id = px.ip_to_service_id(df.remote_addr)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "ip",
              "desc": "The IP to convert.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The service id if it exists, otherwise an empty string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "itoa",
        "brief": "Convert an integer into a string.",
        "desc": "This function converts an integer into a string.",
        "examples": [
          {
            "value": "```\ndf.val = px.itoa(df.int_col)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The integer to convert.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The input converted to a string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "kafka_api_key_name",
        "brief": "Convert a Kafka API key to its name.",
        "desc": "UDF to convert Kafka API keys into their corresponding human-readable names.",
        "examples": [
          {
            "value": "```\ndf.api_key_name = px.kafka_api_key_name(df.req_cmd)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "api_key",
              "desc": "A Kafka API key",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The API key's name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "length",
        "brief": "Returns the length of the string",
        "examples": [
          {
            "value": "```\ndf.service = 'checkout'\ndf.length = px.length(df.service) # 8\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "s",
              "desc": "The string to get the length of",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The length of the string.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "lessThan",
        "brief": "Returns which value is less than the other.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.lt = df.a \u003c df.b\nExplicit call.\ndf.lt = px.lessThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThan",
        "brief": "Returns which value is less than the other.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.lt = df.a \u003c df.b\nExplicit call.\ndf.lt = px.lessThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "TIME64NS"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThan",
        "brief": "Returns which value is less than the other.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.lt = df.a \u003c df.b\nExplicit call.\ndf.lt = px.lessThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "FLOAT64"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThan",
        "brief": "Returns which value is less than the other.",
        "examples": [
          {
            "value": "```\n# Implict call.\ndf.lt = df.a \u003c df.b\nExplicit call.\ndf.lt = px.lessThan(df.a, df.b)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "STRING"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThanEqual",
        "brief": "Returns which value is less than or equal to the the other.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.lte = df.cpu1 \u003c= df.cpu2\n# Explicit call.\ndf.lte = px.lessThanOrEqual(df.cpu1, df.cup2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than or equal to the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThanEqual",
        "brief": "Returns which value is less than or equal to the the other.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.lte = df.cpu1 \u003c= df.cpu2\n# Explicit call.\ndf.lte = px.lessThanOrEqual(df.cpu1, df.cup2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "FLOAT64"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than or equal to the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThanEqual",
        "brief": "Returns which value is less than or equal to the the other.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.lte = df.cpu1 \u003c= df.cpu2\n# Explicit call.\ndf.lte = px.lessThanOrEqual(df.cpu1, df.cup2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "TIME64NS"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than or equal to the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "lessThanEqual",
        "brief": "Returns which value is less than or equal to the the other.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.lte = df.cpu1 \u003c= df.cpu2\n# Explicit call.\ndf.lte = px.lessThanOrEqual(df.cpu1, df.cup2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the expression.",
              "type": "STRING"
            },
            {
              "ident": "b2",
              "desc": "Right side of the expression.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "Whether the left side is less than or equal to the right.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "ln",
        "brief": "Computes the natural log.",
        "desc": "The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp).",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The natural log of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "ln",
        "brief": "Computes the natural log.",
        "desc": "The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp).",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The natural log of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log",
        "brief": "Computes the log base (b).",
        "desc": "The logarithm is the base-b logarithm: the inverse of the exponential function (pow(b, v).",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b",
              "desc": "The base of the the logarithm",
              "type": "FLOAT64"
            },
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The log base b of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log",
        "brief": "Computes the log base (b).",
        "desc": "The logarithm is the base-b logarithm: the inverse of the exponential function (pow(b, v).",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b",
              "desc": "The base of the the logarithm",
              "type": "FLOAT64"
            },
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The log base b of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log",
        "brief": "Computes the log base (b).",
        "desc": "The logarithm is the base-b logarithm: the inverse of the exponential function (pow(b, v).",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b",
              "desc": "The base of the the logarithm",
              "type": "INT64"
            },
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The log base b of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log",
        "brief": "Computes the log base (b).",
        "desc": "The logarithm is the base-b logarithm: the inverse of the exponential function (pow(b, v).",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b",
              "desc": "The base of the the logarithm",
              "type": "INT64"
            },
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The log base b of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log10",
        "brief": "Computes the log base-10.",
        "desc": "The natural logarithm is the base-10 logarithm: the inverse of the 10^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The log base-10 of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log10",
        "brief": "Computes the log base-10.",
        "desc": "The natural logarithm is the base-10 logarithm: the inverse of the 10^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The log base-10 of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log2",
        "brief": "Computes the log base-2.",
        "desc": "The natural logarithm is the base-2 logarithm: the inverse of the 2^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The log base-2 of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "log2",
        "brief": "Computes the log base-2.",
        "desc": "The natural logarithm is the base-2 logarithm: the inverse of the 2^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value to take the logarithm of",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The log base-2 of v",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "logicalAnd",
        "brief": "Boolean ANDs the passed in values.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.can_filter_and_has_data = df.can_filter and df.has_data\n# Explicit call.\ndf.can_filter_and_has_data = px.logicalAnd(df.can_filter, df.has_data)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the AND.",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "desc": "Right side of the AND.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if both expressions are Truthy otherwise False.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "logicalAnd",
        "brief": "Boolean ANDs the passed in values.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.can_filter_and_has_data = df.can_filter and df.has_data\n# Explicit call.\ndf.can_filter_and_has_data = px.logicalAnd(df.can_filter, df.has_data)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the AND.",
              "type": "BOOLEAN"
            },
            {
              "ident": "b2",
              "desc": "Right side of the AND.",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if both expressions are Truthy otherwise False.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "logicalNot",
        "brief": "Boolean NOTs the passed in value.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.not_can_filter = not df.can_filter\n# Explicit call.\ndf.not_can_filter = px.logicalNot(df.can_filter)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "The value to Invert.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if input is Falsey otherwise False.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "logicalNot",
        "brief": "Boolean NOTs the passed in value.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.not_can_filter = not df.can_filter\n# Explicit call.\ndf.not_can_filter = px.logicalNot(df.can_filter)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "The value to Invert.",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if input is Falsey otherwise False.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "logicalOr",
        "brief": "Boolean ORs the passed in values.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.can_filter_or_has_data = df.can_filter or df.has_data\n# Explicit call.\ndf.can_filter_or_has_data = px.logicalOr(df.can_filter, df.has_data)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the OR.",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "desc": "Right side of the OR.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if either expression is Truthy or both expressions are Truthy, otherwise False.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "logicalOr",
        "brief": "Boolean ORs the passed in values.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.can_filter_or_has_data = df.can_filter or df.has_data\n# Explicit call.\ndf.can_filter_or_has_data = px.logicalOr(df.can_filter, df.has_data)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "Left side of the OR.",
              "type": "BOOLEAN"
            },
            {
              "ident": "b2",
              "desc": "Right side of the OR.",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if either expression is Truthy or both expressions are Truthy, otherwise False.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "max",
        "brief": "Returns the maximum in the group.",
        "examples": [
          {
            "value": "```\ndf = df.agg(max_latency=('latency_ms', px.max))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The maximum value in the group.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "max",
        "brief": "Returns the maximum in the group.",
        "examples": [
          {
            "value": "```\ndf = df.agg(max_latency=('latency_ms', px.max))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The maximum value in the group.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "max",
        "brief": "Returns the maximum in the group.",
        "examples": [
          {
            "value": "```\ndf = df.agg(max_latency=('latency_ms', px.max))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "TIME64NS"
            }
          ],
          "result": {
            "desc": "The maximum value in the group.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "mean",
        "brief": "Calculate the arithmetic mean.",
        "desc": "Calculates the arithmetic mean by summing the values then dividing by the number of values.",
        "examples": [
          {
            "value": "```\ndf = df.agg(mean=('latency_ms', px.mean))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data to average.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The mean of the data.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "mean",
        "brief": "Calculate the arithmetic mean.",
        "desc": "Calculates the arithmetic mean by summing the values then dividing by the number of values.",
        "examples": [
          {
            "value": "```\ndf = df.agg(mean=('latency_ms', px.mean))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data to average.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The mean of the data.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "mean",
        "brief": "Calculate the arithmetic mean.",
        "desc": "Calculates the arithmetic mean by summing the values then dividing by the number of values.",
        "examples": [
          {
            "value": "```\ndf = df.agg(mean=('latency_ms', px.mean))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data to average.",
              "type": "BOOLEAN"
            }
          ],
          "result": {
            "desc": "The mean of the data.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "min",
        "brief": "Returns the minimum in the group.",
        "examples": [
          {
            "value": "```\ndf = df.agg(min_latency=('latency_ms', px.min))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The minimum.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "min",
        "brief": "Returns the minimum in the group.",
        "examples": [
          {
            "value": "```\ndf = df.agg(min_latency=('latency_ms', px.min))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The minimum.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "min",
        "brief": "Returns the minimum in the group.",
        "examples": [
          {
            "value": "```\ndf = df.agg(min_latency=('latency_ms', px.min))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The data on which to apply the function.",
              "type": "TIME64NS"
            }
          ],
          "result": {
            "desc": "The minimum.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "modulo",
        "brief": "Calculates the remainder of the division of the two numbers",
        "desc": "Calculates the remainder of dividing the first argument by the second argument. Same results as the C++ modulo operator. Accessible using the `%` syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.duration_mod_5s = df.duration % px.seconds(5)\n# Explicit call.\ndf.duration_mod_5s = px.modulo(df.duration, px.seconds(5))\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The dividend.",
              "type": "TIME64NS"
            },
            {
              "ident": "n",
              "desc": "The divisor.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The remainder of dividing `a` by `n`",
            "type": "INT64"
          }
        }
      },
      {
        "name": "modulo",
        "brief": "Calculates the remainder of the division of the two numbers",
        "desc": "Calculates the remainder of dividing the first argument by the second argument. Same results as the C++ modulo operator. Accessible using the `%` syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.duration_mod_5s = df.duration % px.seconds(5)\n# Explicit call.\ndf.duration_mod_5s = px.modulo(df.duration, px.seconds(5))\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The dividend.",
              "type": "TIME64NS"
            },
            {
              "ident": "n",
              "desc": "The divisor.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "The remainder of dividing `a` by `n`",
            "type": "INT64"
          }
        }
      },
      {
        "name": "modulo",
        "brief": "Calculates the remainder of the division of the two numbers",
        "desc": "Calculates the remainder of dividing the first argument by the second argument. Same results as the C++ modulo operator. Accessible using the `%` syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.duration_mod_5s = df.duration % px.seconds(5)\n# Explicit call.\ndf.duration_mod_5s = px.modulo(df.duration, px.seconds(5))\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The dividend.",
              "type": "INT64"
            },
            {
              "ident": "n",
              "desc": "The divisor.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "The remainder of dividing `a` by `n`",
            "type": "INT64"
          }
        }
      },
      {
        "name": "modulo",
        "brief": "Calculates the remainder of the division of the two numbers",
        "desc": "Calculates the remainder of dividing the first argument by the second argument. Same results as the C++ modulo operator. Accessible using the `%` syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.duration_mod_5s = df.duration % px.seconds(5)\n# Explicit call.\ndf.duration_mod_5s = px.modulo(df.duration, px.seconds(5))\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The dividend.",
              "type": "INT64"
            },
            {
              "ident": "n",
              "desc": "The divisor.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The remainder of dividing `a` by `n`",
            "type": "INT64"
          }
        }
      },
      {
        "name": "multiply",
        "brief": "Multiplies the arguments.",
        "desc": "Multiplies the two values together. Accessible using the `*` operator syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.mult = df.duration * 2\n# Explicit call.\ndf.mult = px.multiply(df.duration, 2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The first value to multiply.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The second value to multiply.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The product of `a` and `b`.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "multiply",
        "brief": "Multiplies the arguments.",
        "desc": "Multiplies the two values together. Accessible using the `*` operator syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.mult = df.duration * 2\n# Explicit call.\ndf.mult = px.multiply(df.duration, 2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The first value to multiply.",
              "type": "FLOAT64"
            },
            {
              "ident": "b",
              "desc": "The second value to multiply.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The product of `a` and `b`.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "multiply",
        "brief": "Multiplies the arguments.",
        "desc": "Multiplies the two values together. Accessible using the `*` operator syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.mult = df.duration * 2\n# Explicit call.\ndf.mult = px.multiply(df.duration, 2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The first value to multiply.",
              "type": "FLOAT64"
            },
            {
              "ident": "b",
              "desc": "The second value to multiply.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The product of `a` and `b`.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "multiply",
        "brief": "Multiplies the arguments.",
        "desc": "Multiplies the two values together. Accessible using the `*` operator syntax.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.mult = df.duration * 2\n# Explicit call.\ndf.mult = px.multiply(df.duration, 2)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The first value to multiply.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The second value to multiply.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The product of `a` and `b`.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "mux_frame_type_name",
        "brief": "Convert a Mux frame type to its name.",
        "desc": "UDF to convert Mux frame type into their corresponding human-readable names.",
        "examples": [
          {
            "value": "```\ndf.frame_type_name = px.mux_frame_type_name(df.req_cmd)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "frame_type",
              "desc": "A Mux frame_type in numeric value",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The mux frame type name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "mysql_command_name",
        "brief": "Convert a MySQL command code to its name.",
        "desc": "UDF to convert MySQL request command codes into their corresponding names.",
        "examples": [
          {
            "value": "```\ndf.cmd = px.mysql_command_name(df.req_cmd)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "cmd",
              "desc": "A MySQL command code",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The request code's name.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "negate",
        "brief": "Negates the passed in value.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.negative_latency_ms = -df.latency_ms\n# Explicit call.\ndf.negative_latency_ms = px.negate(df.latency_ms)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "The value to negate.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "`b1` with a flipped negative sign.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "negate",
        "brief": "Negates the passed in value.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.negative_latency_ms = -df.latency_ms\n# Explicit call.\ndf.negative_latency_ms = px.negate(df.latency_ms)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "desc": "The value to negate.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "`b1` with a flipped negative sign.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "normalize_mysql",
        "brief": "Normalizes MySQL queries by replacing constants with placeholders.",
        "desc": "Replaces constants with '?' placeholder.Outputs the normalized query along with the values of the parameters",
        "examples": [
          {
            "value": "```\n# Normalize the SQL query.\n# px.mysql_command_code(3) == 'Query'\ndf.normalized_sql_json = px.normalize_mysql(\"SELECT * FROM test WHERE prop=@a AND prop2='abcd'\", 3)\n# Pluck the relevant values from the json.\n# Value: 'SELECT * FROM test WHERE prop=@a AND prop2=?'\ndf.normed_query = px.pluck(df.normalized_sql_json, 'query')\n# Value: ['abcd']\ndf.params = px.pluck(df.normalized_sql_json, 'params')\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "sql_string",
              "desc": "The MySQL query string",
              "type": "STRING"
            },
            {
              "ident": "cmd_code",
              "desc": "The MySQL command code for this sql request.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The normalized query with the values of the parameters in the query as JSON. Available keys: ['query', 'params', 'error']. Error will be non-empty if the query could not be normalized.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "normalize_pgsql",
        "brief": "Normalizes PostgresSQL queries by replacing constants with placeholders.",
        "desc": "Replaces constants with '$n' placeholders.Outputs the normalized query along with the values of the parameters",
        "examples": [
          {
            "value": "```\n# Normalize the SQL query.\ndf.normalized_sql_json = px.normalize_pgsql('SELECT * FROM test WHERE prop='abcd', 'Query')\n# Pluck the relevant values from the json.\n# Value: 'SELECT * FROM test WHERE prop=$1'\ndf.normed_query = px.pluck(df.normalized_sql_json, 'query')\n# Value: ['abcd']\ndf.params = px.pluck(df.normalized_sql_json, 'params')\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "sql_string",
              "desc": "The PostgresSQL query string",
              "type": "STRING"
            },
            {
              "ident": "cmd_code",
              "desc": "The PostgresSQL command tag for this sql request.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The normalized query with the values of the parameters in the query as JSON. Available keys: ['query', 'params', 'error']. Error will be non-empty if the query could not be normalized.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "STRING"
            },
            {
              "ident": "b2",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "BOOLEAN"
            },
            {
              "ident": "b2",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "TIME64NS"
            },
            {
              "ident": "b2",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "UINT128"
            },
            {
              "ident": "b2",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "BOOLEAN"
            },
            {
              "ident": "b2",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "INT64"
            },
            {
              "ident": "b2",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "notEqual",
        "brief": "Returns whether the values are not equal.",
        "desc": "Determines whether the values are not equal. Passing in floating-point values might lead to false positives. Use `not px.approxEqual(b1, b2)` to compare floats instead.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.failed_http = df.http_status != 200\n# Explicit call.\ndf.failed_http = px.notEqual(df.http_status, 200)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "b1",
              "type": "FLOAT64"
            },
            {
              "ident": "b2",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "True if `b1` is not equal to `b2`, False otherwise.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "nslookup",
        "brief": "Perform a DNS lookup for the value (experimental).",
        "desc": "Experimental UDF to perform a DNS lookup for a given value.",
        "examples": [
          {
            "value": "```\ndf.hostname = px.nslookup(df.ip_addr)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "addr",
              "desc": "An IP address",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The hostname.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pluck",
        "brief": "Grabs the value for the key value the serialized JSON string and returns as a string.",
        "desc": "Convenience method to handle grabbing keys from a serialized JSON string. The function parses the JSON string and attempts to find the key. If the key is not found, an empty string is returned.\nThis function returns the value as a string. If you want an int, use `px.pluck_int64`. If you want a float, use `px.pluck_float64`.",
        "examples": [
          {
            "value": "```\ndf.quantiles = '{\"p50\": 5.1, \"p90\": 10}'\ndf.p50 = px.pluck(df.quantiles, 'p50') # \"5.1\", as a string.\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "json_str",
              "desc": "JSON data serialized as a string.",
              "type": "STRING"
            },
            {
              "ident": "key",
              "desc": "The key to get the value for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The value for the key as a string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pluck_array",
        "brief": "Grabs the ith value in the array from the serialized JSON string and returns as a string.",
        "desc": "Convenience method to handle grabbing the ith item in an array from a serialized JSON string. The function parses the array JSON string and attempts to find the ith element. If the JSON string is not an array, or the index is out of range, an empty string is returned.\nThis function returns the ith element as a string.",
        "examples": [
          {
            "value": "```\ndf.json = '{\"names\": [\"foo\", \"bar\"]}'\ndf.names = px.pluck(df.json, \"names\") # Returns [\"foo\", \"bar\"]\ndf.name0 = px.pluck_array(df.names, 0) # Returns \"foo\"\ndf.name5 = px.pluck_array(df.names, 5) # Returns \"\"\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "json_str",
              "desc": "JSON data serialized as a string.",
              "type": "STRING"
            },
            {
              "ident": "index",
              "desc": "The index of the value in the array.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value at the ith position in the array as a string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pluck_float64",
        "brief": "Grabs the value for the key from the serialized JSON string and returns as a float.",
        "desc": "Convenience method to handle grabbing keys from a serialized JSON string. The function parses the JSON string and attempts to find the key. If the key is not found, 0.0 is returned. If the key is found, but the value cannot be parsed as an int, returns a 0.0.\nThis function returns the value as a float. If you want a string, use `px.pluck`. If you want an int, use `px.pluck_int64`.",
        "examples": [
          {
            "value": "```\ndf.http_data = '{\"status_code\": 200, \"p50_latency\": 5.1}'\ndf.p50_latency = px.pluck_float64(df.http_data, 'p50_latency') # 5.1\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "json_str",
              "desc": "JSON data serialized as a string.",
              "type": "STRING"
            },
            {
              "ident": "key",
              "desc": "The key to get the value for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The value for the key as a float",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "pluck_int64",
        "brief": "Grabs the value for the key from the serialized JSON string and returns as an int.",
        "desc": "Convenience method to handle grabbing keys from a serialized JSON string. The function parses the JSON string and attempts to find the key. If the key is not found, 0 is returned. If the key is found, but the value cannot be parsed as an int, returns a 0.\nThis function returns the value as an int. If you want a string, use `px.pluck`. If you want a float, use `px.pluck_float64`.",
        "examples": [
          {
            "value": "```\ndf.http_data = '{\"status_code\": 200, \"p50_latency\": 5.1}'\ndf.status_code = px.pluck_int64(df.http_data, 'status_code') # 200\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "json_str",
              "desc": "JSON data serialized as a string.",
              "type": "STRING"
            },
            {
              "ident": "key",
              "desc": "The key to get the value for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The value for the key as an int.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "pod_id_to_deployment_id",
        "brief": "Get the ID of the Deployment which controls the pod with pod ID.",
        "desc": "Gets the Kubernetes ID for the Deployment that owns the Pod (specified by Pod ID).If this pod is not controlled by any Deployment, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.deployment_id = px.pod_id_to_deployment_id(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the Deployment ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Deployment ID wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_deployment_name",
        "brief": "Get the name of the Deployment which controls the pod with pod ID.",
        "desc": "Gets the Kubernetes name for the Deployment that owns the Pod (specified by Pod ID).If this pod is not controlled by any Deployment, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replicaset_name = px.pod_id_to_deployment_name(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the Deployment name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Deployment name wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_namespace",
        "brief": "Get the Kubernetes namespace from a pod ID.",
        "desc": "Gets the Kubernetes namespace that the Pod ID belongs to.",
        "examples": [
          {
            "value": "```\ndf.namespace = px.pod_id_to_namespace(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the namespace for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s namespace for the Pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_node_name",
        "brief": "Get the name of the node a pod ID is running on.",
        "desc": "Gets the Kubernetes name for the node that the Pod (specified by Pod ID) is running on.",
        "examples": [
          {
            "value": "```\ndf.node_name = px.pod_id_to_node_name(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the node name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s node name for the Pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_owner_references",
        "brief": "Get the owner references for a given pod ID.",
        "desc": "Gets the owner references for the pod. If there is no owner references associated to this pod, then this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.owner_references = px.pod_id_to_owner_references(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get owner references for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s owner references for the Pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_pod_labels",
        "brief": "Get labels of a pod from its pod ID.",
        "desc": "Gets the kubernetes pod labels for the pod from its pod ID.",
        "examples": [
          {
            "value": "```\ndf.labels = px.pod_id_to_pod_labels(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The pod ID of the pod to get the labels for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s pod labels for the pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_pod_name",
        "brief": "Get the name of a pod from its pod ID.",
        "desc": "Gets the kubernetes name for the pod from its pod ID.",
        "examples": [
          {
            "value": "```\ndf.pod_name = px.pod_id_to_pod_name(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The pod ID of the pod to get the name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s pod name for the pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_replicaset_id",
        "brief": "Get the ID of the Replica Set which controls the pod with pod ID.",
        "desc": "Gets the Kubernetes ID for the Replica Set that owns the Pod (specified by Pod ID).If this pod is not controlled by any Replica Set, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replicaset_id = px.pod_id_to_replicaset_id(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the Replica Set ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Replica Set ID wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_replicaset_name",
        "brief": "Get the name of the Replica Set which controls the pod with pod ID.",
        "desc": "Gets the Kubernetes name for the Replica Set that owns the Pod (specified by Pod ID).If this pod is not controlled by any Replica Set, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replicaset_name = px.pod_id_to_replicaset_name(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the Replica Set name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Replica Set name wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_service_id",
        "brief": "Get the service ID for a given pod ID.",
        "desc": "Gets the Kubernetes service ID for the service associated to the pod. If there is no service associated to this pod, then this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_id = px.pod_id_to_service_id(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get service ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s service ID for the Pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_service_name",
        "brief": "Get the service name for a given pod ID.",
        "desc": "Gets the Kubernetes service name for the service associated to the pod. If there is no service associated to this pod, then this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_name = px.pod_id_to_service_name(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get service name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s service name for the Pod ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_id_to_start_time",
        "brief": "Get the start time of a pod from its ID.",
        "desc": "Gets the start time (in nanosecond unix time format) of a pod from its pod ID.",
        "examples": [
          {
            "value": "```\ndf.pod_start_time = px.pod_id_to_start_time(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the start time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Pod ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "pod_id_to_stop_time",
        "brief": "Get the stop time of a pod from its ID.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a pod from its pod ID.",
        "examples": [
          {
            "value": "```\ndf.pod_stop_time = px.pod_id_to_stop_time(df.pod_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The Pod ID of the Pod to get the stop time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Pod ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "pod_name_to_deployment_id",
        "brief": "Get the ID of the Deployment which controls the pod with the specified pod name.",
        "desc": "Gets the Kubernetes ID for the Deployment that owns the Pod (specified by pod name).If this pod is not controlled by any Deployment, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replica_set_id = px.pod_name_to_deployment_id(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The Pod name of the Pod to get the Deployment ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Deployment ID wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_deployment_name",
        "brief": "Get the name of the Deployment which controls the pod with the specified pod name.",
        "desc": "Gets the Kubernetes name for the Deployment that owns the Pod (specified by pod name).If this pod is not controlled by any Deployment, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replica_set_name = px.pod_name_to_deployment_name(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The Pod name of the Pod to get the Deployment name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Deployment name wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_namespace",
        "brief": "Get the Kubernetes namespace from a pod name.",
        "desc": "Gets the Kubernetes namespace that the pod belongs to.",
        "examples": [
          {
            "value": "```\ndf.namespace = px.pod_name_to_namespace(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the Pod to get the namespace for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s namespace for the pod passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_owner_references",
        "brief": "Get the owner references for a given pod name.",
        "desc": "Gets the owner references for the pod (specified by the pod_name). If there is no owner references associated to this pod, then this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.owner_references = px.pod_name_to_owner_references(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The Pod name of the Pod to get service ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s owner references for the Pod name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_pod_id",
        "brief": "Get the id of a pod from its name.",
        "desc": "Gets the kubernetes ID for the pod from its name.",
        "examples": [
          {
            "value": "```\ndf.pod_id = px.pod_name_to_pod_id(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the pod to get the ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s pod ID for the pod name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_pod_ip",
        "brief": "Get the IP address of a pod from its name.",
        "desc": "Gets the IP address for the pod from its name.",
        "examples": [
          {
            "value": "```\ndf.pod_ip = px.pod_name_to_pod_ip(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the pod to get the IP for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The pod IP for the pod name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_replicaset_id",
        "brief": "Get the ID of the Replica Set which controls the pod with the specified pod name.",
        "desc": "Gets the Kubernetes ID for the Replica Set that owns the Pod (specified by pod name).If this pod is not controlled by any Replica Set, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replica_set_id = px.pod_name_to_replicaset_id(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The Pod name of the Pod to get the Replica Set ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Replica Set ID wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_replicaset_name",
        "brief": "Get the name of the Replica Set which controls the pod with the specified pod name.",
        "desc": "Gets the Kubernetes name for the Replica Set that owns the Pod (specified by pod name).If this pod is not controlled by any Replica Set, returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replica_set_name = px.pod_name_to_replicaset_name(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The Pod name of the Pod to get the Replica Set name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s Replica Set name wich controls the Pod with the Pod ID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_service_id",
        "brief": "Get the service ID for a given pod name.",
        "desc": "Gets the Kubernetes service ID for the service associated to the pod. If there is no service associated to this pod, then this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_id = px.pod_name_to_service_id(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_id",
              "desc": "The name of the Pod to get service ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s service ID for the Pod name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_service_name",
        "brief": "Get the service name for a given pod name.",
        "desc": "Gets the Kubernetes service name for the service associated to the pod. If there is no service associated to this pod, then this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_name = px.pod_name_to_service_name(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the Pod to get service name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The k8s service name for the Pod name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_start_time",
        "brief": "Get the start time of a pod from its name.",
        "desc": "Gets the start time (in nanosecond unix time format) of a pod from its name.",
        "examples": [
          {
            "value": "```\ndf.pod_start_time = px.pod_name_to_start_time(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the Pod to get the start time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Pod name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "pod_name_to_status",
        "brief": "Get status information about the given pod.",
        "desc": "Gets the Kubernetes status information for the pod with the given name. The status is a subset of the Kubernetes PodStatus object returned as JSON. The keys included are state, message, and reason. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podstatus-v1-core for more info about this object. ",
        "examples": [
          {
            "value": "```\ndf.pod_status = px.pod_name_to_status(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the pod to get the PodStatus for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Kubernetes PodStatus for the Pod passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "pod_name_to_stop_time",
        "brief": "Get the stop time of a pod from its name.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a pod from its name.",
        "examples": [
          {
            "value": "```\ndf.pod_stop_time = px.pod_name_to_stop_time(df.pod_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pod_name",
              "desc": "The name of the Pod to get the stop time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Pod name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "pow",
        "brief": "Computes the power function.",
        "desc": "Computes the power function x^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "x",
              "desc": "The base of the exponent",
              "type": "FLOAT64"
            },
            {
              "ident": "y",
              "desc": "The exponent",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value x^y",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "pow",
        "brief": "Computes the power function.",
        "desc": "Computes the power function x^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "x",
              "desc": "The base of the exponent",
              "type": "FLOAT64"
            },
            {
              "ident": "y",
              "desc": "The exponent",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value x^y",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "pow",
        "brief": "Computes the power function.",
        "desc": "Computes the power function x^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "x",
              "desc": "The base of the exponent",
              "type": "INT64"
            },
            {
              "ident": "y",
              "desc": "The exponent",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value x^y",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "pow",
        "brief": "Computes the power function.",
        "desc": "Computes the power function x^y",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "x",
              "desc": "The base of the exponent",
              "type": "INT64"
            },
            {
              "ident": "y",
              "desc": "The exponent",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value x^y",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "protocol_name",
        "brief": "Convert a protocol code to its corresponding name.",
        "desc": "UDF to convert the internal Pixie protocol numbers into their corresponding protocol names.",
        "examples": [
          {
            "value": "```\ndf.protocol_name = px.protocol_name(df.protocol)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "protocol",
              "desc": "A protocol code",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The name of the protocol.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "quantiles",
        "brief": "Approximates the distribution of the aggregated data.",
        "desc": "Calculates several useful percentiles of the aggregated data using [tdigest](https://github.com/tdunning/t-digest). Returns a serialized JSON object with the keys for 1%, 10%, 50%, 90%, and 99%. You can use `px.pluck_float64` to grab the specific values from the result.",
        "examples": [
          {
            "value": "```\n# Calculate the quantiles.\ndf = df.agg(latency_dist=('latency_ms', px.quantiles))\n# Pluck p99 from the quantiles.\ndf.p99 = px.pluck_float64(df.latency_dist, 'p99')\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to calculate the quantiles distribution.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The quantiles data, serialized as a JSON dictionary.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "quantiles",
        "brief": "Approximates the distribution of the aggregated data.",
        "desc": "Calculates several useful percentiles of the aggregated data using [tdigest](https://github.com/tdunning/t-digest). Returns a serialized JSON object with the keys for 1%, 10%, 50%, 90%, and 99%. You can use `px.pluck_float64` to grab the specific values from the result.",
        "examples": [
          {
            "value": "```\n# Calculate the quantiles.\ndf = df.agg(latency_dist=('latency_ms', px.quantiles))\n# Pluck p99 from the quantiles.\ndf.p99 = px.pluck_float64(df.latency_dist, 'p99')\n\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "val",
              "desc": "The data to calculate the quantiles distribution.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The quantiles data, serialized as a JSON dictionary.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "redact_pii_best_effort",
        "brief": "Make a best effort to redact Personally Identifiable Information (PII).",
        "desc": "Replace instances of PII with '\u003cREDACTED_$TYPE\u003e' eg. '\u003cREDACTED_EMAIL\u003e' or '\u003cREDACTED_IPv4\u003e'. Currently, it will (on a best effort basis) redact IP addresses, email addresses, MAC addresses, IMEI numbers, credit card numbers, and IBAN numbers. However, the redaction is not perfect, so it should not be used in a context where privacy needs to be guaranteed.",
        "examples": [
          {
            "value": "```\ndf.redacted = px.redact_pii_best_effort(df.req_body)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "input_str",
              "desc": "The string to redact PII from.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The input string with instances of PII replaced with \u003cREDACTED\u003e.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "regex_match",
        "brief": "Check for a match to a regex pattern in a string.",
        "desc": "This function checks the input string (second arg) for a match with the regex pattern (first arg). The regex pattern must match the full string. For example, the pattern 'abc' doesn't match the string 'abcd' but the pattern 'abc*' does match that string. We support google RE2 syntax. More details on that syntax can be found [here](https://github.com/google/re2/wiki/Syntax). ",
        "examples": [
          {
            "value": "```\ndf.is_match = px.regex_match('.*my_regex_pattern.*', df.resp_body)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The regex pattern to match.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The string column to match the pattern against.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "boolean representing whether the pattern matched the input or not.",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "replace",
        "brief": "Replace all matches of a regex pattern in a string with another string.",
        "desc": "This function replaces all matches of the regex pattern (first arg) in the string (second arg) with the substitution string (third arg). We support google RE2 syntax. More details on that syntax can be found [here](https://github.com/google/re2/wiki/Syntax). Note that numbered capture groups are supported and can be accessed in the substitution string with \\1...\\N. See the google RE2 docs for more details on capture groups. However, named capture groups are not supported.",
        "examples": [
          {
            "value": "```\ndf.replaced_str = px.replace('10\\.0\\.0\\.[0-9]+', df.resp_body, 'IP_ADDR')\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The regex pattern to replace.",
              "type": "STRING"
            },
            {
              "ident": "arg2",
              "desc": "The string column to replace pattern occurrences in.",
              "type": "STRING"
            },
            {
              "ident": "arg3",
              "desc": "The string to replace the pattern with.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The original string with all occurrences of the pattern replaced by the substitution string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_deployment_id",
        "brief": "Get the Deployment ID of a Replica Set from its ID.",
        "desc": "Gets the Deployment ID of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.deployment_id =px.replicaset_id_to_deployment_id(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the Deployment ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Deployment ID for the Replica Set ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_deployment_name",
        "brief": "Get the Deployment name of a Replica Set from its ID.",
        "desc": "Gets the Deployment name of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.deployment_name =px.replicaset_id_to_deployment_name(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the Deployment name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Deployment name for the Replica Set ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_namespace",
        "brief": "Get the namespace of a Replica Set from its ID.",
        "desc": "Gets the namespace of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.namespace = px.replicaset_id_to_namespace(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the namespace for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The namespace for the Replica Set ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_owner_references",
        "brief": "Get the owner references of a Replica Set from its ID.",
        "desc": "Gets the owner references of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.owner_references = px.replicaset_id_to_owner_references(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the owner references for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The owner references for the Replica Set ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_replicaset_name",
        "brief": "Get the Replica Set Name from a Replica Set ID.",
        "desc": "Gets the Kubernetes Replica Set Name for the Replica Set ID.If the given ID doesn't have an associated Kubernetes Replica Set, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.replica_set_name = px.replicaset_id_to_replicaset_name(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The UID of the Replica Set to get the name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Replica Set Name for the UID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_start_time",
        "brief": "Get the start time of a Replica Set from its ID.",
        "desc": "Gets the start time (in nanosecond unix time format) of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.rs_start_time = px.replicaset_id_to_start_time(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the start time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Replica Set ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "replicaset_id_to_status",
        "brief": "Get the status of a Replica Set from its ID.",
        "desc": "Gets the status of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.status = px.replicaset_id_to_status(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the status for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The status for the Replica Set ID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_id_to_stop_time",
        "brief": "Get the stop time of a Replica Set from its ID.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a Replica Set from its ID.",
        "examples": [
          {
            "value": "```\ndf.rs_stop_time = px.replicaset_id_to_stop_time(replica_set_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_id",
              "desc": "The Replica Set ID of the Replica Set to get the stop time for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Replica Set ID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "replicaset_name_to_deployment_id",
        "brief": "Get the Deployment ID of a Replica Set from its name.",
        "desc": "Gets the Deployment ID of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.deployment_id = px.replicaset_name_to_deployment_id(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The Replica Set name of the Replica Set to get the Deployment ID for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Deployment ID for the Replica Set name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_name_to_deployment_name",
        "brief": "Get the Deployment name of a Replica Set from its name.",
        "desc": "Gets the Deployment name of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.deployment_name = px.replicaset_name_to_deployment_name(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The Replica Set name of the Replica Set to get the Deployment name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Deployment name for the Replica Set name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_name_to_namespace",
        "brief": "Get the namespace of a Replica Set from its name.",
        "desc": "Gets the namespace of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.namespace = px.replicaset_name_to_namespace(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The name of the Replica Set to get the name for. The name includes the namespace of the Replica Set. i.e. \"ns/rs_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The namespace for the Replica Set name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_name_to_owner_references",
        "brief": "Get the owner references of a Replica Set from its name.",
        "desc": "Gets the owner references of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.owner_references = px.replicaset_name_to_owner_references(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The name of the Replica Set to get the name for. The name includes the namespace of the Replica Set. i.e. \"ns/rs_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The owner references for the Replica Set name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_name_to_replicaset_id",
        "brief": "Get the Replica Set ID from a Replica Set name.",
        "desc": "Gets the Kubernetes Replica Set ID for the Replica Set name.If the given name doesn't have an associated Kubernetes Replica Set, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.replica_set_id = px.replicaset_name_to_replicaset_id(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The name of the Replica Set to get the name for. The name includes the namespace of the Replica Set. i.e. \"ns/rs_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Replica Set ID for the name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_name_to_start_time",
        "brief": "Get the start time of a Replica Set from its name.",
        "desc": "Gets the start time (in nanosecond unix time format) of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.rs_start_time = px.replicaset_name_to_start_time(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The name of the Replica Set to get the name for. The name includes the namespace of the Replica Set. i.e. \"ns/rs_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The start time (as an integer) for the Replica Set name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "replicaset_name_to_status",
        "brief": "Get the status of a Replica Set from its name.",
        "desc": "Gets the status of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.owner_references = px.replicaset_name_to_status(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The name of the Replica Set to get the name for. The name includes the namespace of the Replica Set. i.e. \"ns/rs_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The status for the Replica Set name passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "replicaset_name_to_stop_time",
        "brief": "Get the stop time of a Replica Set from its name.",
        "desc": "Gets the stop time (in nanosecond unix time format) of a Replica Set from its name.",
        "examples": [
          {
            "value": "```\ndf.rs_stop_time = px.replicaset_name_to_stop_time(replica_set_name)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "replica_set_name",
              "desc": "The name of the Replica Set to get the name for. The name includes the namespace of the Replica Set. i.e. \"ns/rs_name\"",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The stop time (as an integer) for the Replica Set name passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "round",
        "brief": "Rounds the float to the nearest decimal places.",
        "desc": "Rounds the float to the nearest decimal place and returns value as a string. Used to clean up the data shown in tables. Set decimals to `0` if you want to round to the nearest int value.",
        "examples": [
          {
            "value": "```\ndf.cpu1 = 0.248\ndf.cpu1 = px.round(df.cpu1, 2) # 0.25\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to round.",
              "type": "FLOAT64"
            },
            {
              "ident": "decimals",
              "desc": "Number of decimal places to round to. `0` =\u003e round to nearest int.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Float rounded to the specified decimal place as a string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "select",
        "brief": "Selects value based on the first argument.",
        "examples": [
          {
            "value": "```\n# Explicit call.\ndf.val = px.select(df.select_left, df.left, df.right)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "s",
              "desc": "The selector value",
              "type": "BOOLEAN"
            },
            {
              "ident": "v1",
              "desc": "The return value when s is true",
              "type": "BOOLEAN"
            },
            {
              "ident": "v2",
              "desc": "The return value when s is false",
              "type": "BOOLEAN"
            }
          ],
          "retval": {
            "desc": "Return v1 if s else v2",
            "type": "BOOLEAN"
          }
        }
      },
      {
        "name": "select",
        "brief": "Selects value based on the first argument.",
        "examples": [
          {
            "value": "```\n# Explicit call.\ndf.val = px.select(df.select_left, df.left, df.right)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "s",
              "desc": "The selector value",
              "type": "BOOLEAN"
            },
            {
              "ident": "v1",
              "desc": "The return value when s is true",
              "type": "INT64"
            },
            {
              "ident": "v2",
              "desc": "The return value when s is false",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "Return v1 if s else v2",
            "type": "INT64"
          }
        }
      },
      {
        "name": "select",
        "brief": "Selects value based on the first argument.",
        "examples": [
          {
            "value": "```\n# Explicit call.\ndf.val = px.select(df.select_left, df.left, df.right)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "s",
              "desc": "The selector value",
              "type": "BOOLEAN"
            },
            {
              "ident": "v1",
              "desc": "The return value when s is true",
              "type": "FLOAT64"
            },
            {
              "ident": "v2",
              "desc": "The return value when s is false",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "Return v1 if s else v2",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "select",
        "brief": "Selects value based on the first argument.",
        "examples": [
          {
            "value": "```\n# Explicit call.\ndf.val = px.select(df.select_left, df.left, df.right)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "s",
              "desc": "The selector value",
              "type": "BOOLEAN"
            },
            {
              "ident": "v1",
              "desc": "The return value when s is true",
              "type": "TIME64NS"
            },
            {
              "ident": "v2",
              "desc": "The return value when s is false",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "Return v1 if s else v2",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "select",
        "brief": "Selects value based on the first argument.",
        "examples": [
          {
            "value": "```\n# Explicit call.\ndf.val = px.select(df.select_left, df.left, df.right)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "s",
              "desc": "The selector value",
              "type": "BOOLEAN"
            },
            {
              "ident": "v1",
              "desc": "The return value when s is true",
              "type": "STRING"
            },
            {
              "ident": "v2",
              "desc": "The return value when s is false",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "Return v1 if s else v2",
            "type": "STRING"
          }
        }
      },
      {
        "name": "service_id_to_cluster_ip",
        "brief": "Convert the Kubernetes service ID to its cluster IP.",
        "desc": "Converts the Kubernetes service ID to the cluster IP of the service. If either the service ID or IP is not found in our mapping, then returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.cluster_ip = px.service_id_to_cluster_ip(df.service_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service_id",
              "desc": "The service ID to get the service name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The cluster IP or an empty string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "service_id_to_external_ips",
        "brief": "Convert the Kubernetes service ID to its external IP addresses.",
        "desc": "Converts the Kubernetes service ID to the external IPs of the service as an array. If the the service ID is not found in our mapping, then returns an empty string. If the service ID is found but has no external IPs, then returns an empty array. ",
        "examples": [
          {
            "value": "```\ndf.external_ips = px.service_id_to_external_ips(df.service_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service_id",
              "desc": "The service ID to get the service name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The external IPs or an empty string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "service_id_to_service_name",
        "brief": "Convert the Kubernetes service ID to service name.",
        "desc": "Converts the Kubernetes service ID to the name of the service. If the ID is not found in our mapping, then returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service = px.service_id_to_service_name(df.service_id)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service_id",
              "desc": "The service ID to get the service name for.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The service name or an empty string if service_id not found.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "service_name_to_namespace",
        "brief": "Gets the namespace from the service name.",
        "desc": "Extracts the namespace from the service name. It expects the service name to come in the format`\u003cnamespace\u003e/\u003cservice_name\u003e`, otherwise it'll return an empty string.",
        "examples": [
          {
            "value": "```\n# df.service is `pl/kelvin`\ndf.namespace = px.service_name_to_namespace(df.service) # \"pl\"\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service_name",
              "desc": "The service to extract the namespace.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The namespace of the service.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "service_name_to_service_id",
        "brief": "Convert the service name to the service ID.",
        "desc": "Converts the service name to the corresponding kubernetes service ID. If the name is not found in our mapping, the function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_id = px.service_name_to_service_id(df.service)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "service_name",
              "desc": "The service to get the service ID.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The kubernetes service ID for the service passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "shared_libraries",
        "brief": "Get the shared libraries for a given pid.",
        "desc": "Get the shared libraries for a given pid.",
        "examples": [
          {
            "value": "```\ndf.libraries = px.shared_libraries(df.pid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "pid",
              "desc": "The process ID",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "Stringified vector of shared libraries.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "sqrt",
        "brief": "Compute the sqrt",
        "desc": "Computes the sqrt",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "The value sqrt(v)",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "sqrt",
        "brief": "Compute the sqrt",
        "desc": "Computes the sqrt",
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "v",
              "desc": "The value",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The value sqrt(v)",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "strip_prefix",
        "brief": "Strips the specified prefix from the string.",
        "desc": "Returns the string with the prefix removed. Will return the same string if the prefix not found.",
        "examples": [
          {
            "value": "```\n# df.service is `pl/kelvin`\ndf.removed_pl = px.strip_prefix('pl/', df.service) # \"kelvin\"\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "prefix",
              "desc": "The prefix to remove.",
              "type": "STRING"
            },
            {
              "ident": "string",
              "desc": "The string value to strip the prefix from.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "`string` with `prefix` removed from the beginning if it existed.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "substring",
        "brief": "Returns the specified substring from the string",
        "desc": "Extracts the substring from the string starting at index `pos` and for `length` characters. If `pos \u003e len(string)`, `px.substr` returns the empty string. If `pos \u003c len(string)` but `pos + length \u003e len(string)`, `px.substr` returns the maximum length substring starting at `pos`",
        "examples": [
          {
            "value": "```\ndf.service = 'checkout'\ndf.str = px.substring(df.service, 1, 5) # 'hecko'\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "string",
              "desc": "The string to get the substring from.",
              "type": "STRING"
            },
            {
              "ident": "pos",
              "desc": "The position to start the substring, inclusive.",
              "type": "INT64"
            },
            {
              "ident": "length",
              "desc": "The length of the substring to return.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The substring from `string`.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "FLOAT64"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "FLOAT64"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "FLOAT64"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "TIME64NS"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "TIME64NS"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "subtract",
        "brief": "Arithmetically subtract the first argument by the second argument.",
        "desc": "This function is implicitly invoked by the - operator.",
        "examples": [
          {
            "value": "```\n# Implicit call.\ndf.subtracted = df.a - df.b\n# Explicit call.\ndf.subtracted = px.subtract(df.a, df.b)\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "a",
              "desc": "The value to be subtracted from.",
              "type": "INT64"
            },
            {
              "ident": "b",
              "desc": "The value to subtract.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "`a` with `b` subtracted from it.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "sum",
        "brief": "Calculate the arithmetic sum of the grouped values.",
        "examples": [
          {
            "value": "```\ndf = df.agg(sum=('latency_ms', px.sum))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The group to sum.",
              "type": "FLOAT64"
            }
          ],
          "result": {
            "desc": "The sum of the data.",
            "type": "FLOAT64"
          }
        }
      },
      {
        "name": "sum",
        "brief": "Calculate the arithmetic sum of the grouped values.",
        "examples": [
          {
            "value": "```\ndf = df.agg(sum=('latency_ms', px.sum))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The group to sum.",
              "type": "INT64"
            }
          ],
          "result": {
            "desc": "The sum of the data.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "sum",
        "brief": "Calculate the arithmetic sum of the grouped values.",
        "examples": [
          {
            "value": "```\ndf = df.agg(sum=('latency_ms', px.sum))\n```"
          }
        ],
        "udaDoc": {
          "updateArgs": [
            {
              "ident": "arg",
              "desc": "The group to sum.",
              "type": "BOOLEAN"
            }
          ],
          "result": {
            "desc": "The sum of the data.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "time_to_int64",
        "brief": "Converts a time value to an int64 value",
        "desc": "Converts a time value to an int64 value. Used when type-specific UDFs are needed for int64 on a time value.",
        "examples": [
          {
            "value": "```\ndf = df[px.time_to_int64(df.time_) != 0]\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "value",
              "desc": "The value to convert.",
              "type": "TIME64NS"
            }
          ],
          "retval": {
            "desc": "The time (in nanoseconds) as an int64.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "tolower",
        "brief": "Transforms all uppercase ascii characters in the string to lowercase.",
        "examples": [
          {
            "value": "```\ndf.service  = \"Kelvin\"\ndf.lower = px.tolower(df.service) # \"kelvin\"\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "string",
              "desc": "The string to transform.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "`string` with all uppercase ascii converted to lowercase.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "toupper",
        "brief": "Transforms all lowercase ascii characters in the string to uppercase.",
        "examples": [
          {
            "value": "```\ndf.service = Kelvin\ndf.upper = px.toupper(df.service) # \"KELVIN\"\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "string",
              "desc": "The string to transform.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "`string` with all lowercase ascii converted to uppercase.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "trim",
        "brief": "Trim ascii whitespace from before and after the string content.",
        "desc": "Returns a copy of the string with the white space before and after the string trimmed away. Does not affect whitespace in between words.",
        "examples": [
          {
            "value": "```\ndf.service = \"        pl/kelvin \"\ndf.trimmed = px.trim(df.service) # \"pl/kelvin\"\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "string",
              "desc": "The string to transform.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "The string but with leading and trailing whitespace removed.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid",
        "brief": "Convert a pid, start_time pair to a UPID.",
        "desc": "This function creates a UPID from it's underlying components.",
        "examples": [
          {
            "value": "```\ndf.val = px.upid(px.asid(), df.pid, df.pid_start_time)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The asid of the pem where the process is located.",
              "type": "INT64"
            },
            {
              "ident": "arg2",
              "desc": "The pid of the process.",
              "type": "INT64"
            },
            {
              "ident": "arg3",
              "desc": "The start_time of the process.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The UPID.",
            "type": "UINT128"
          }
        }
      },
      {
        "name": "upid",
        "brief": "Convert a pid, start_time pair to a UPID.",
        "desc": "This function creates a UPID from it's underlying components.",
        "examples": [
          {
            "value": "```\ndf.val = px.upid(df.pid, df.pid_start_time)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "arg1",
              "desc": "The pid of the process.",
              "type": "INT64"
            },
            {
              "ident": "arg2",
              "desc": "The start_time of the process.",
              "type": "INT64"
            }
          ],
          "retval": {
            "desc": "The UPID.",
            "type": "UINT128"
          }
        }
      },
      {
        "name": "upid_to_asid",
        "brief": "Get the Pixie Agent ID from the UPID.",
        "desc": "Gets the Pixie Agent ID from the given Unique Process ID (UPID). The Pixie Agent ID signifies which Pixie Agent is tracing the given process.",
        "examples": [
          {
            "value": "```\ndf.agent_id = px.upid_to_asid(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the Pixie Agent ID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Pixie Agent ID for the UPID passed in.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "upid_to_cmdline",
        "brief": "Get the command line arguments used to start a UPID.",
        "desc": "Get the command line arguments used to start the process with the given Unique Process ID (UPID).",
        "examples": [
          {
            "value": "```\ndf.cmdline = px.upid_to_cmdline(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID to get the command line arguments for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The command line arguments for the UPID passed in, as a string.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_container_id",
        "brief": "Get the Kubernetes container ID from a UPID.",
        "desc": "Gets the Kubernetes container ID for the container the process with the given Unique Process ID (UPID) is running on. If the UPID has no associated Kubernetes container, this function will return an empty string",
        "examples": [
          {
            "value": "```\ndf.container_id = px.upid_to_container_id(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the container ID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The k8s container ID for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_container_name",
        "brief": "Get the Kubernetes container name from a UPID.",
        "desc": "Gets the Kubernetes container name for the container the process with the given Unique Process ID (UPID) is running on. If the UPID has no associated Kubernetes container, this function will return an empty string",
        "examples": [
          {
            "value": "```\ndf.container_name = px.upid_to_container_name(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the container name for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The k8s container name for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_deployment_id",
        "brief": "Get the Deployment ID from a UPID.",
        "desc": "Gets the Kubernetes Deployment ID for the process with the given Unique Process ID (UPID). If the given process doesn't have an associated Kubernetes Deployment, this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.deployment_id = px.upid_to_deployment_id(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the Deployment ID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Deployment ID for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_deployment_name",
        "brief": "Get the Deployment Name from a UPID.",
        "desc": "Gets the Kubernetes Deployment Name for the process with the given Unique Process ID (UPID). If the given process doesn't have an associated Kubernetes Deployment, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.deployment_name = px.upid_to_deployment_name(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the Deployment name for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Deployment Name for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_hostname",
        "brief": "Get the Hostname from a UPID.",
        "desc": "Gets the name of the host the process with the given Unique Process ID (UPID) is running on. Equivalent to running `hostname` in a shell on the node the process is running on.",
        "examples": [
          {
            "value": "```\ndf.hostname = px.upid_to_hostname(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the hostname for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The hostname for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_namespace",
        "brief": "Get the Kubernetes namespace from a UPID.",
        "desc": "Gets the Kubernetes namespace for the process with the given Unique Process ID (UPID). If the process is not running within a kubernetes context, this function will return an empty string",
        "examples": [
          {
            "value": "```\ndf.namespace = px.upid_to_namespace(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the namespace for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The k8s namespace for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_node_name",
        "brief": "Get the Node Name from a UPID.",
        "desc": "Gets the Kubernetes name of the node the process with the given Unique Process ID (UPID) is running on.",
        "examples": [
          {
            "value": "```\ndf.node_name = px.upid_to_node_name(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the node name for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The name of the node for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_pid",
        "brief": "Get the PID of the process for the given UPID.",
        "desc": "Get the process ID for the process the Unique Process ID (UPID) refers to. Note that the UPID is unique across all hosts/containers, whereas the PID could be the same between different hosts/containers",
        "examples": [
          {
            "value": "```\ndf.pid = px.upid_to_pid(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the PID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The PID for the UPID passed in.",
            "type": "INT64"
          }
        }
      },
      {
        "name": "upid_to_pod_id",
        "brief": "Get the Kubernetes Pod ID from a UPID.",
        "desc": "Gets the Kubernetes pod ID for the pod the process with the given Unique Process ID (UPID) is running on. If the UPID has no associated Kubernetes Pod, this function will return an empty string.",
        "examples": [
          {
            "value": "```\ndf.pod_id = px.upid_to_pod_id(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the pod ID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The k8s pod ID for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_pod_name",
        "brief": "Get the Kubernetes Pod Name from a UPID.",
        "desc": "Gets the name of Kubernetes pod the process with the given Unique Process ID (UPID) is running on. If the UPID has no associated Kubernetes Pod, this function will return an empty string",
        "examples": [
          {
            "value": "```\ndf.pod_name = px.upid_to_pod_name(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the pod name for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The k8s pod name for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_pod_qos",
        "brief": "Get the Kubernetes QOS class for the UPID.",
        "desc": "Gets the Kubernetes QOS class for the pod the given Unique Process ID (UPID) is running on. The QOS Class is one of \"Guaranteed\", \"Burstable\", or \"BestEffort\". See https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/ for more info.",
        "examples": [
          {
            "value": "```\ndf.pod_qos = px.upid_to_pod_qos(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID to get the Pod QOS class for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Pod QOS class for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_pod_status",
        "brief": "Get status information about the pod of a UPID.",
        "desc": "Gets the Kubernetes status information for the pod the given Unique Process ID (UPID) is running on. The status is a subset of the Kubernetes PodStatus object returned as JSON. The keys included are state, message, and reason. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podstatus-v1-core for more info about this object. If the UPID has no associated kubernetes pod, this will return an empty string.",
        "examples": [
          {
            "value": "```\ndf.pod_status = px.upid_to_pod_status(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID to get the PodStatus for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes PodStatus for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_replicaset_id",
        "brief": "Get the Replica Set ID from a UPID.",
        "desc": "Gets the Kubernetes Replica Set ID for the process with the given Unique Process ID (UPID). If the given process doesn't have an associated Kubernetes Replica Set, this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.replica_set_id = px.upid_to_replicaset_id(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the service ID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Replica Set ID for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_replicaset_name",
        "brief": "Get the Replica Set Name from a UPID.",
        "desc": "Gets the Kubernetes Replica Set Name for the process with the given Unique Process ID (UPID). If the given process doesn't have an associated Kubernetes Replica Set, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.replica_set_name = px.upid_to_replicaset_name(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the service name for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Replica Set Name for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_service_id",
        "brief": "Get the Service ID from a UPID.",
        "desc": "Gets the Kubernetes Service ID for the process with the given Unique Process ID (UPID). If the given process doesn't have an associated Kubernetes service, this function returns an empty string.",
        "examples": [
          {
            "value": "```\ndf.service_id = px.upid_to_service_id(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the service ID for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The kubernetes service ID for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_service_name",
        "brief": "Get the Service Name from a UPID.",
        "desc": "Gets the Kubernetes Service Name for the process with the given Unique Process ID (UPID). If the given process doesn't have an associated Kubernetes service, this function returns an empty string",
        "examples": [
          {
            "value": "```\ndf.service_name = px.upid_to_service_name(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID of the process to get the service name for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The Kubernetes Service Name for the UPID passed in.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "upid_to_start_ts",
        "brief": "Get the starting timestamp of the process for the given UPID.",
        "desc": "Get the starting timestamp for the process referred to by the Unique Process ID (UPID). ",
        "examples": [
          {
            "value": "```\ndf.timestamp = px.upid_to_start_ts(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The unique process ID of the process to get the starting timestamp for.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The starting timestamp for the UPID passed in.",
            "type": "TIME64NS"
          }
        }
      },
      {
        "name": "upid_to_string",
        "brief": "Get a stringified version of the UPID.",
        "desc": "Stringifies a UPID The string format of the UPID is `asid:pid:start_time`, where asid is the Pixie Agent unique ID that uniquely determines which Pixie Agent traces this UPID, pid is the process ID from the host, and start_time is the unix time the process started.",
        "examples": [
          {
            "value": "```\ndf.upid_str = px.upid_to_string(df.upid)\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "upid",
              "desc": "The UPID to stringify.",
              "type": "UINT128"
            }
          ],
          "retval": {
            "desc": "The stringified UPID.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "uri_parse",
        "brief": "Parses the URI into it's component parts and returns the parts as a JSON string.",
        "examples": [
          {
            "value": "```\ndf.uri = 'https://px.dev/community/?param1=val1'\ndf.parsed = px.uri_parse(df.uri)\ndf.path = px.pluck(df.parsed, 'path') # /community/\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "uri",
              "desc": "The uri to parse.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "A JSON string representation with the URI parts.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "uri_recompose",
        "brief": "Recomposes the URI parts int a URI.",
        "examples": [
          {
            "value": "```\ndf.uri = px.uri_recompose('https', '', 'px.dev', 0, '/community/', 'param1=val1', '') # https://px.dev/community/?param1=val1\n\n```"
          }
        ],
        "scalarUdfDoc": {
          "args": [
            {
              "ident": "scheme",
              "desc": "The scheme for the URI.",
              "type": "STRING"
            },
            {
              "ident": "userInfo",
              "desc": "The userInfo for the URI.",
              "type": "STRING"
            },
            {
              "ident": "host",
              "desc": "The host for the URI.",
              "type": "STRING"
            },
            {
              "ident": "port",
              "desc": "The port for the URI.",
              "type": "INT64"
            },
            {
              "ident": "path",
              "desc": "The path for the URI.",
              "type": "STRING"
            },
            {
              "ident": "query",
              "desc": "The query for the URI.",
              "type": "STRING"
            },
            {
              "ident": "fragment",
              "desc": "The fragment for the URI.",
              "type": "STRING"
            }
          ],
          "retval": {
            "desc": "A fully composed URI.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "vizier_id",
        "brief": "Get the ID of the cluster.",
        "desc": "Get the ID of the Vizier.",
        "examples": [
          {
            "value": "```\ndf.vizier_id = px.vizier_id()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The vizier ID of the cluster.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "vizier_name",
        "brief": "Get the name of the cluster.",
        "desc": "Get the name of the Vizier.",
        "examples": [
          {
            "value": "```\ndf.vizier_name = px.vizier_name()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The name of the cluster according to vizier.",
            "type": "STRING"
          }
        }
      },
      {
        "name": "vizier_namespace",
        "brief": "Get the namespace where Vizier is deployed.",
        "desc": "Get the Kubernetes namespace in which the Vizier is deployed.",
        "examples": [
          {
            "value": "```\ndf.vizier_namespace = px.vizier_namespace()\n```"
          }
        ],
        "scalarUdfDoc": {
          "retval": {
            "desc": "The Kubernetes namespace in which Vizier is deployed",
            "type": "STRING"
          }
        }
      }
    ]
  }
}